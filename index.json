[{"content":"Choria Broker is a set of features that, in a fully decentralized setup, is the only central component Choria needs. It is highly available, clustered and very high performance. The messaging layer is based on NATS with a number of Choria specific additions.\nA single Choria Broker can manage 50,000 devices on a low budget compute instance - though a cluster of at least 3 brokers is recommended for availability reasons.\nFeatures  Choria Brokers is the core message passing middleware, this is a managed NATS Core instance Choria Streams is the data streaming solution used by various Choria components, this is a managed NATS JetStream instance Choria Federation Broker connects entirely isolated Choria networks into a federated single network Choria Data Adapters to move data from Choria Broker to other technologies A Choria specific authentication layer  ","description":"","tags":null,"title":"Choria Broker","uri":"/broker/index.html"},{"content":"Choria Broker is just one process running in your server, the command systemctl status choria-broker will show a basic overview of the process running, you should have basic monitoring for the process in place.\nPrometheus Metrics By default, the broker does not expose any monitoring metrics, if you set the plugin.choria.stats_port configuration to a port number it will listen on that port. You can listen on non localhost by setting plugin.choria.stats_address.\nIt will then serve a number of URLs, some from Choria and some from the embedded NATS Server - see NATS Monitoring for detail about those.\n   Path Description     /choria/ Build information, run-time resource use   /choria/metrics Prometheus format metrics    System Account Monitoring NATS and Choria Streams require a System account enabled:\nplugin.choria.network.system.user = system plugin.choria.network.system.password = s3cret This should be set in the Broker configuration and any client who wish to access the broker.\nWe have a basic Dashboard you can use to view these.\nIncluded Checks  Tip All the choria broker server commands are from the embedded NATS CLI and so can be an awkward fit within our CLI hierarchy\n  We include a number of checks in the binary that can be used to monitor various aspects of the service.\n   Command Description     choria broker server check connection Performs a basic network connection and round-trip test of the NATS service   choria broker server check stream Checks the health of individual Choria Streams Streams   choria broker server check meta Checks the health of the overall Choria Streams System   choria broker server check jetstream Checks Choria Streams usage limits   choria broker server check server Checks the health of the embedded NATS Server   choria broker server check kv Checks the health of Choria Key-Value buckets    All of these Checks require the System Account to be enabled in your broker and the client configuration to have the same settings. A custom Choria Client configuration can be set using --choria-config on these commands.\nBy default, these commands act like Nagios checks:\n% choria broker server check js OK JetStream | memory=0B memory_pct=0%;75;90 storage=1942997776B storage_pct=0%;75;90 streams=13 streams_pct=0% consumers=21 consumers_pct=0% % echo $? 0 They can though also output json, prometheus and text formats:\n% choria broker server check js --format text JetStream: OK Check Metrics ╭───────────────┬───────────────┬──────┬────────────────────┬───────────────────╮ │ Metric │ Value │ Unit │ Critical Threshold │ Warning Threshold │ ├───────────────┼───────────────┼──────┼────────────────────┼───────────────────┤ │ memory │ 0.00 │ B │ 0.00 │ 0.00 │ │ memory_pct │ 0.00 │ % │ 90.00 │ 75.00 │ │ storage │ 1942955289.00 │ B │ 0.00 │ 0.00 │ │ storage_pct │ 0.00 │ % │ 90.00 │ 75.00 │ │ streams │ 13.00 │ │ 0.00 │ 0.00 │ │ streams_pct │ 0.00 │ % │ -1.00 │ -1.00 │ │ consumers │ 21.00 │ │ 0.00 │ 0.00 │ │ consumers_pct │ 0.00 │ % │ -1.00 │ -1.00 │ ╰───────────────┴───────────────┴──────┴────────────────────┴───────────────────╯ Reports Several run time reports are included that can show connection states and more, all of these require the System Account.\nList Brokers in the cluster This shows all the connected NATS Servers / Choria Brokers in your cluster and some basic information about them\n$ choria broker server list Broker Connections You can view and search active connections to your brokers, here we limit it to the top-5 by subject, see --help for other options\n% choria broker server report connections --top 5 Add the --account=provisioning option to see connections waiting to be provisioned if enabled.\nStreams Report One can get a overview of Choria Streams backends:\n% choria broker server report jetstream Details Broker Data A wealth of data is available in the Brokers about every connection and every subscription and more, run choria broker server req --help to see a full list.\nGolang Profiling As an advanced option, that should not be enabled by default, one can enable the Golang PProf port to facilitate deep debugging of memory allocations and more. How to use this is out of scope of this document and really only useful for developers.\nplugin.choria.network.pprof_port = 9090 ","description":"","tags":null,"title":"Monitoring","uri":"/broker/monitoring/index.html"},{"content":"Choria Server is designed to not open any listening ports unless its Apple HomeKit integration is enabled.\nWithout any opening ports monitoring it is via a state file that it writes regularly when enabled:\nplugin.choria.status_file_path = /var/log/choria-status.json plugin.choria.status_update_interval = 30 The above configuration will cause the status file to update every 30 seconds. This needs to be enabled for any deep introspection.\nNagios Check A nagios protocol test is included in the command choria tool status, this can check various aspects of the server operation.\n$ choria tool status --status-file /var/log/choria-status.json \\ --disconnected \\ # alerts when the server is not connected to a broker --message-since 1h \\ # must have received RPC requests within the last 1 hour --max-age 1m \\ # Status file may not be older than 1 minute --token-age 24h \\ # Alert 1 day before the token expires --certificate-age 24h \\ # Alert 1 day before the certificate expires --provisioned # Alerts if the server is in provisioned mode Autonomous Agent Check A running instance can check itself using an Autonomous Agent, it will then public Cloud Events about it’s internal state and, optionally, expose it’s state to a local Prometheus Node Exporter via its text file directory.\nwatchers:  - name: check_choria  type: nagios  interval: 5m # checks every 5 minutes, require the status file to be 15 minutes or newer  properties:  builtin: choria_status  token_expire: 1d  # alerts when the token expires soon  pubcert_expire: 1d  # alerts when the certificate expires soon  last_message: 1h  # alerts when no RPC message was received in 1 hour Review the Autonomous Agent section for full detail about these checks.\nIf you have Prometheus Node Exporter running locally with an argument --collector.textfile.directory=/var/lib/node_exporter/textfile set you can configure this path in Choria which would cause the above Autonomous Agent to write status to that directory:\nplugin.choria.prometheus_textfile_directory = /var/lib/node_exporter/textfile Lifecycle Events Choria will publish a number of events in Cloud Events format, these can be observed using choria tool event, this will include start, stop, provisioned etc events from every Choria Server instance.\nSome details about these events are in these blog posts:\n Choria Lifecycle Events Transitioning Events to Cloud Events  ","description":"","tags":null,"title":"Monitoring","uri":"/server/monitoring/index.html"},{"content":"Background Current State The Choria V1 protocol requires x509, there is no other option.\nExperience with mcollective showed that companies had little appetite to understand or use esoteric security protocols, even those based on sound industry standard cryptographic methods. Further most companies already had mature x509 infrastructure either standalone or part of systems like Puppet which made for an easy adoption path.\nChoria therefor is built on a protocol that requires x509 semantics and supports nothing else:\n Every message is signed by a x509 key Every client-initiated message contains the x509 public key Servers listen on TLS using x509 public and private keys User identities are tied to the properties of the certificates User permissions and roles are tied to the identity of the certificate, very limited support for fine-grained roles All JWT files are signed by x509 keys Generally only RSA is supported mTLS is used to create a private network - requiring a purpose specific CA or intermediate CA in practice A local cache of certificates is used like a kind of safety check to catch credentials being re-issued Any NATS client connecting to Choria broker requires a cert/key/ca and do full mTLS  Choria supports a mode combined with the AAA Server where a user does not need her own x509 certificate but holds a JWT instead obtained from an SSO service. In this scenario the AAA Server still holds a x509 cert (called a privileged certificate) and is allowed to sign and encode requests on behalf of others (holders of a JWT) by using its x509 key pair to sign on behalf of the user.\nProblem Statement In practice this works well for most users, but those with very large or complex networks can run into problems either with corporate Certificate Authority policies or corporate CA configuration making it very hard to achieve a secure network with the facilities available. General CA infrastructure is also just getting a bit old and better alternatives exist. JWTs are now used pervasively in modern IT and the user based are more likely to accept their use for our needs.\nWe would like to explore, and enable, other use cases outside of server management such as IoT, purpose built backplanes, Kubernetes side cars and more, integration into Certificate Authorities in those cases is really problematic.\n x509 signatures are big and slow x509 certificates are also huge and these go with every request x509 certificate management, especially across multiple client machines is very difficult Dealing with short-lived (minutes) x509 certificates can be really hard Not all CAs have sane enrollment, some requires private keys to be copied around making them useless Newer technologies like ed25519 is attractive as they use small keys and signatures and can also do things like DH Key exchange Using ed25519 opens the possibility of using ssh keys as signing keys, something many users have requested Obtaining private CAs or intermediate CAs is often impossible forcing CA reuse and nullifying the usefulness of the mTLS security Verification of certificates happen during caching rather than a separate check, more importantly the cache is used often as a means of retrieving privileged certs and more by id The local cert cache is deeply embedded in the v1 protocol, but it’s proven to be useless and most people disable its enforcing features - it cannot be disabled entirely As Choria have evolved we need a much more granular role based permissions on each connection - can they use streams, can they admin streams, can they make rpc requests etc More and more servers need to be able to make request either when publishing signed registration payloads or when interacting with Choria Services from within autonomous agents. With v1 protocol this was not possible.  Solution Overview We will support an additional protocol, while maintaining v1 protocol, that will be based on JWTs signed using ed25519 that embed their public component in the signed JWT.\nWe have already done the work to design and incorporate the JWTs for clients and servers at the transport level but now need to move that work into the Choria protocol so clients can communicate with Choria without x509 certificates.\nTransport Security Transport security is primarily about how the packets between Choria Broker and Choria Client/Server are secured but touches a bit on how users with access to the NATS Server are limited to just their traffic.\nmTLS optional Chain of Trust for transport security In a mTLS secured network trust is established by way of the CA signing all certificates and all parties verifying this fact. Both sides of the TLS connection will verify the other side to ensure its certificate is signed by a cached local CA chain.\nThis way there can be no untrusted middlemen or session hijacking in the network path.\nIn practice, in enterprise networks, there are many challenges:\n it’s often highly desirable to be able to hijack connections, for example to audit that PII doesn’t leave the legal jurisdiction it belongs in, many companies wish to disable the full mTLS while still maintaining strong identification of entities. it’s also desirable to deploy Choria Brokers using websocket protocol and offload the TLS work onto a load balancer - this would be quite complex with the current model. most enterprise have policies making CA rotation necessary and quite frequent, this makes mTLS completely unworkable at scale. dropping mTLS, or not being able to do mTLS, would impact the strength of identity since we combine the transport and identity in one cert certificate enrolment is done poorly, there are few protocols like ACME in use in Enterprises, often they would design their own enrollment, and mostly it involves moving keys between machines and are very slow  So we will support verified or unverified TLS to the brokers, but clients and servers all must present a signed JWT when not in mTLS mode. This will split the identity from transport security and give people the choice to pick one without compromising the other.\nServers and clients will have:\n An ed25519 seed file example server.seed kept private and never transmitted over the network A JWT file that holds:  the public key of the ed25519 seed an identity a private network ID derived from the identity or seed Standard items like expiry times etc Additional permissions to control access to broker subjects   The JWT will be signed by a trusted ed25519 key  The broker will only allow connections that holds a valid, signed JWT where the signature is made using a trusted ed25519 key.\nOrganization and Chained Issuers Conceptually Choria Broker can separate connections into something called “accounts” in NATS terms, for Choria we call this an Organization. Today we support just one Organization - choria - but we will look to support more in future.\nWe will add a concept called an Organization Issuer that is a ed25519 key that must, on a basic level, sign all tokens. To facilitate separation of concerns in our centralized AAA mode the Issuer can delegate JWT issuing in a chain to downstream issuers. The tokens will validate as being signed by the issuer essentially.\nWe support storing the Organization Issuer offline in something like Vault and at the “AAA Login Server” level that issuing key can also be stored in a Vault like system.\n  \nThus, we achieve the following chain of trust:\n We know the JWT was issued by a trusted issuer We verify the connecting server or client has the ed25519 seed that match the JWT because the broker force a NONCE to be signed using the seed, the seed never traverse the network since the public part is embedded in the signed JWT The JWT tokens are therefor not bearer tokens and if they are stolen in-flight (remember no mTLS), one cannot connect with them or make any requests using them We have an identity that isn’t tied to the common name of a cert and so is more fluid and adaptable The broker should support denying all clients without JWTs  In this way we can pick full mTLS when needed or JWT+ed25519 mode when needed and even mix and match the modes.\nReply Security Reply security is a quite difficult problem to solve since every reply would need to be individually encrypted and decrypted - unlike transport security - this is very CPU intensive, so we have never really done it at scale.\nStill, its highly desirable to hide replies destined for a specific user from other users, even those with access to the broker using their own JWT tokens.\nUsing the callerID as key we calculate a private inbox using the hex encoded md5(callerID), we use this to construct reply subjects for all uses, even access to other subjects like the Streams API.\nThe broker will set up permissions ensuring that only the callerID can access replies. This way as long as there are unique callerIDs the replies from all systems are private.\nWe still do not encrypt the traffic in-transit (see point about PII and desired man-in-the-middle in Enterprises), but the replies are private to the user.\n% sudo choria jwt client.jwt ... Private Network ID: 7419405695a186147a0de38f7e31a509... ... % choria req choria_util info --debug DEBU[0000] Publishing message with reply to choria.reply.7419405695a186147a0de38f7e31a509.4e27ca6493cb4576bb78e90ea35df38c component=client Here we can see the reply is set to match \u003ccollective\u003e.reply.\u003cprivate network id\u003e.\u003crequest id\u003e, the broker ensures the holder of this JWT cannot subscribe to other users replies.\nTo facilitate debugging users with the OrgAdmin permission, default not granted, on their tokens can view all replies.\nSubmission and Registration Data Security As each server will have a ed25519 seed and a JWT embedding the public key we will support, optionally, signing Choria Submission and Registration messages. Signatures and Tokens will be included in headers.\nThis way should a system need to be created where the node will ask in an async manner for operations to be done against it, think host-detected issues triggering auto remediation, these messages originating from Submission will be signed.\nRecipients of these messages can be certain that the message originated from a place that had access to the nodes private key.\nSee #1873\nIdentity Identity primarily concerns Choria Requests, this is who is the one making the request for the use by AAA.\nTraditionally this is extracted from the x509 certificate common name and have some dumb rules like x.choria or x.privileged.choria since x509 certificates don’t really have a strong concept of boolean permissions.\nThis is awful and arbitrary, in the new model callers should be whatever they like and a flag on the JWT would identify it as privileged or not (#1836).\nCaller Identity Identity would always be extracted from the JWT of the final client. In the case of the AAA Service we would need to have the ability to include the client JWT as well as the signer JWT and the signature:\n When the signer JWT isn’t set we ensure the client signed it. When the signer JWT is set we ensure the JWT has the right permission to sign others requests (#1836) The identity of the client JWT is used for the request We should be able to issue JWTs that can only be used in conjunction with an AAA server who signs their requests (#1840)  This would be the identity used in things like RBAC, Audit logs and more.\nThe broker might set the NATS user to the identity to assist with debugging.\nRequest Signatures Today requests are signed by the x509/RSA key, we’d just sign it with the ed25519 seed instead. We would not support any form of server side cache.\nClient JWTs will gain permissions that state they have fleet management access and, optionally, that fleet management access requires signatures.\nIssuing JWT tokens Traditionally you would use whatever your CA does for enrolling certificates and choria enroll might help you out if you’re lucky to have a system that supports that.\nFor others, it would be up to the user to deliver the key, cert and ca to the right locations.\nHaving Server enroll separate from Client enroll is good, since its conceivable that those will be done in very different places and with different auth mechanisms.\nServers Servers would get their JWT token from the Choria Provisioner, this is supported today and that supports setting permissions and more. The Provisioner would hold a JWT that is a Chain Issuer allowing it to sign JWTs for servers.\nClients The current AAA Server should be extended to allow client enrollment, essentially this is already supported but there is no allowance for the client seed and new behaviors. The signing request should be extended with a signature made using the seed and the service should verify it - essentially same as the NONCE in the broker.\nThe AAA Service would support marking a user as standalone - he can make his own requests without AAA and has his own seed - or as requiring AAA service (#1840). He might have his own seed for signing the broker NONCE but cannot make RPC requests that were not signed by AAA service.\nThe AAA Login handler would hold a JWT that is a Chain Issuer allow it to sign JWTs for the clients and set policies and permissions.\nThe choria jwt command must also be able to issue client credentials.\nNon Choria clients - like lets say a random node nats client - would need to get their hands on a JWT and seed as well, and they will have to connect with that. So there will have to be a way to enroll them, probably choria jwt or choria login with their user marked as being long term valid.\nA final class of client is one that needs a short-lived permission to make a very specific request. Imagine some external orchestrator wants to invoke choria req or choria kv for a particular use. Ideally this external Orchestrator would be able to issue a JWT that would allow this to happen on any unix user. In this scenario choria login should be able to take a bearer token and present that to AAA service during choria login. The bearer token would be signed by the orchestrator and trusted by the AAA, the bearer token would be very short-lived and essentially single use. It will be used to facilitate login, Choria JWT creation and more so that the unix user would still have an ed25519 seed, but the Choria Client JWT would be custom and short-lived and restricted to purpose.\nFederation The federation system allows for moving requests and replies between uncoupled networks - essentially it’s a protocol converter and gateway.\nWe would not in the past create federation that would cross CA boundaries as resigning all the requests and replies was impossible. With the new system the Federation Broker should be able to have a token with Authentication Delegation set and just re-sign the request en-route. This will allow it to do translation between networks and ID schemes.\nImplementation The protocol in Choria largely defines the bytes that traverse the network and couples quite tightly with the security providers for encoding, signing etc.\nIn the work to support v2 protocol we are also revisiting the design of the security plugins to be more generic and support non x509 key data.\nProtocol Layered protocols are used widely and bring with them a lot of flexibility in replacing some layer with another, for example: Ethernet -\u003e IP -\u003e TCP -\u003e HTTP -\u003e REST.\nChoria has a similar design:\n( Transport ( Secure Request or Reply ( Request or Reply ( Any bytes, often: RPC Request or Reply ) ) ) ) The efforts with v2 protocol is to replace Transport, Secure and Request/Reply with a new design, still based on JSON, but with better choices internally.\nRequest A request holds the actual bytes being moved around and various claims about who is making the request.\n   Field v1 Description     protocol protocol The protocol version for this request io.choria.protocol.v2.request   message payload The arbitrary data contained in the request - like a RPC request - as base64 encoded bytes   id requestid The unique ID for the request, logged in AAA etc   sender senderid Typically the host that the request was initiated from   caller callerid Who made the request in the form of kind=name   collective collective Collective this request is targeted at   agent agent The agent this request is targeted at   ttl ttl How long this request is valid for   time time The unix nano time the request was created (unix time in v1)   filter filter The request filter    Secure Request A secure request wraps a Request, signs it and prevents any tampering with its content.\nThe signature - having been made with a private key - also conveys identity and confirms the claimed identity in the Request matches what cryptographic keys are held.\nThe main purpose of the Secure Request is to verify what can be verified about the Request and make immutable the rest. For example, we can’t exactly verify the request time and TTL, but we can prevent it from being changed by an attacker by signing it. The caller in the Request is not verified in the Request since it’s just an arbitrary string, however the Secure Request being signed using something unique to the caller, private key, confirms the information in the request.\nSo the end result is immutable, or at least tamper evident, metadata about a request and likewise the request payload or message.\n   Field v1 Description     protocol protocol The protocol version for this secure request io.choria.protocol.v2.secure_request   request message The request held in the Secure Request as base64 bytes   signature signature A signature made of the request using the ed25519 seed of the caller   caller pubcert The JWT of the caller   signer n/a The JWT of the delegated signer, present when the AAA server is used    Reply A reply is created in response from a request and holds the request id in its payload\n   Field v1 Description     protocol protocol The protocol version for this reply io.choria.protocol.v2.reply   message payload The arbitrary data contained in the reply - like a RPC reply   request requestid The ID of the request this reply relates to   sender senderid The host sending the reply   agent agent The agent the reply originates from   time time The unix nano time the request was created (unix time in v1)    Secure Reply A secure reply wraps a Reply, signs it and prevents any tampering with its content. The hash is a fast way to test validity of the reply.\nLike the Secure Request the Secure Reply wraps the Reply in a way that makes it tamper evident via signatures and hashes.\nThe v2 protocol includes a signature and sender JWT however in practice this is mostly not going to be used as too costly on the receiver, however might be used for registration payload verification.\nSignatures add quite a bit to the payload here, as the JWT has to be sent with, so it can be disabled using plugin.security.choria.sign_replies in the new security provider.\n   Field v1 Description     protocol protocol The protocol version for this secure reply io.choria.protocol.v2.secure_reply   reply message The reply held in the Secure Request as base64 bytes   hash hash A sha256 of the reply   signature n/a A signature made using the ed25519 seed of the sender   sender n/a The JWT of the sending host    Transport The transport packet is the last layer that gets sent over NATS, it holds no message specific data.\n   Field v1 Description     protocol protocol The protocol version for this transport io.choria.protocol.v2.transport   data data The payload to be transport, a Secure Request or Secure Reply base64 encoded   headers headers Optional headers    Headers:\n   Field v1 Description     reply reply-to A transport specific response channel for this message, used in requests   sender mc_sender The host that sent this message   trace seen-by A trace of host/broker pairs that the message traversed   federation federation Headers to assist federation    Federation:\n   Field v1 Description     request req The request ID a federated message belongs to   reply reply-to The original reply before federation   targets targets The identities who the federated message is for    Chained Tokens Verification We created a Chained Token system in #1900 that allows a Organization Issuer to delegate Client and Server creation to Chained Issuers.\nFrom a usage perspective you can say tokens.ParseClientIDToken(t, pubk) where the public key is the public part of the Organization Issuer, even when the token t is signed by a Chain Issuer. The intention is to make the configuration of a chain much easier, you only have to configure the issuer for an Organization.\nAdditionally the expiry of the Chain Issuer is encoded in the token, if the issuer expires first the issued token is also considered expired.\nThe way this is achieved is with a series of claims and signatures as described here:\nThe Organization Issuer for an Organization is simply an ed25519 key for the moment. If that Org Issuer is just signing some client, server or provisioner nothing special is done, it’s just signing a JWT like normal.\nHowever if the Org Issuer wants to create a token that can sign other tokens additional information is added a Clent token, it’s called the Chain Issuer:\n{  \"iss\": \"I-514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec\",  \"jti\": \"0ujsswThIGTUYm2K8FjOOfXtY1K\",  \"ou\": \"choria\",  \"public_key\": \"bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687\",  \"purpose\": \"choria_client_id\",  \"tcs\": \"3f815723734c78ceaba5fb506347565f85fe2a0334c038ba2370c7f53f35e6c7c75ed3e95b531b6049426638201c39639dbf9b711fba5d866e7e3e30be02b401\" }  jti is a unique ID for this token. It’s a kskuid, the time component must match the issued at time iss field indicates it is signed by a Issuer with public key 514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec. public_key is the public part of the ed25519 seed for the Chain Issuer aaa_chain_delegator tcs is a signature made of [chain issuer id].[chain issuer public key] using the Org Issuer private key, in other words sig(\"0ujsswThIGTUYm2K8FjOOfXtY1K.bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687\", orgIssuerPrik) The Chain Issuer JWT is signed by the Organization Issuer  This way we can verify that the Chain Issuer comes from the Issuer both by verifying the signature but also we have a piece of information that cannot be changed down the line (the tcs, signed by the Org Issuer key) which we will see again later.\nIn code this information, signatures etc can all be added using chainIssuer.AddOrgIssuerData(issuerPrik), with this added the token chainIssuer can issue other tokens. For a possible future integration with systems like Vault we would call out to the Vault API to sign the tcs plain text and then sign the token, hence the Organization Issuer private key never needs to leave Vault.\nNow when the Chain Issuer wants to issue a new Client or Server token additional information is again added:\n{  \"callerid\": \"up=rip\",  \"iss\": \"C-0ujsswThIGTUYm2K8FjOOfXtY1K.bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687\",  \"issexp\": 1700153647,  \"jti\": \"b2375f965abe4bfbaf131b585cf5e1a1\",  \"ou\": \"choria\",  \"public_key\": \"676d07de6721ee396754d4e4d5fa4ee2b59a6f3b8208e760ca614bc66000e740\",  \"purpose\": \"choria_client_id\",  \"tcs\": \"3f815723734c78ceaba5fb506347565f85fe2a0334c038ba2370c7f53f35e6c7c75ed3e95b531b6049426638201c39639dbf9b711fba5d866e7e3e30be02b401.a9da5f3946c1b472f1c886912bfe5559f261e4663016846e231095bd2e16a8a253657196a5c17231fb095bc3a2d1e89e1edaddcec35dd050303e5d9cda968a04\" }  jti is a unique id for this token iss indicates a Chain Issuer with token ID (jti) 0ujsswThIGTUYm2K8FjOOfXtY1K issued this token and his public key is bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687 (the one from the previous example) issexp indicates when the Chain Issuer expires tcs is made up of first creating sigdata [client token jti].[chain issuer tcs] and then combining that [chain issuer tcs].[sig(sigdata, chainIssuerPrik)]  This way we can, given the signed Client token and the Org Issuer Public key, validate by going backwards over these claims:\n Extract the Chain Issuer tcs, public key and id from iss and tcs Verify the Organization Issuer signed the tcs of the Chain Issuer in this token, which also verifies the public key in the issuer Verify the tcs signature part of the Client using public key of the Chain Issuer Verify the expiry of the Chain Issuer  General Improvements The security plugins handle signing, encoding, extracting of IDs and validating signatures. The current security plugins are all implemented around x509.\nWe will make some general improvements, rename some functions and add a few bits to the interface, detail to be discovered during implementation.\n Move the API to []byte based API #1844 Remove some string orientated security apis  Make the JWT authoritative for the secure channel name so we can stop using md5 Develop a tool that can decode and dump/view network packets #1484 The entire concept of the cache to be removed #1842 Default collective when v2 is used will be choria #1885 Submission can sign messages #1873 The protocol code should be instances not a singleton so each can have unique contexts and logging Stronger AAA interactions by signing NONCE like data in login and sign requests Potentially entirely remove the concept of Trusted Signers that was a mid term stop gap till this work is complete, only used by 1 users as far as we are aware  ","description":"","tags":null,"title":"V2 Network Protocol","uri":"/adr/001/index.html"},{"content":"This is a guide for early adopters who wish to test and study the Version 2 Protocol and Security project.\n Warning This is a Hard Mode guide that does everything manually and with no Configuration Management.\n  Requirements  Choria Nightly Choria AAA Service Nightly Choria Provisioner Nightly Docker on Intel CPU  Security Credentials Security is by means of a ed25519 key that signs JWTs, some JWTs form a chain and can sign others. Regardless of the signer verification can be done using the public key associated with the Organization Issuer.\n  \nThe Organization Issuer can be kept offline with Provisioning and AAA being delegated authorities capable of signing servers and clients but these are optional components - the Organization Issuer can directly sign Clients and Servers allowing them to operate without the other central components.\nDeployment Methods We demonstrate two deployment methods:\n Decentralized - like traditional Choria with only a broker as shared component Centralized AAA and Provisioning - uses Choria AAA Service and Choria Provisioner for low-touch auto enrolment of Clients and Servers  Additionally, we show how Hashicorp Vault can be integrated to manage the Organization Issuer\n Tip We recommend reviewers really dig into the details here, we do have a Docker Compose environment with this all setup.\n  Decentralized deployment In this model we will deploy a system that resembles the basic architecture diagram below\n  \nWe have only the Brokers as central architecture with no Central AAA or Provisioning.\nWe will not use mTLS in this case. mTLS is supported but a major advantage of this mode is that it’s not required.\nDocker We will need two Docker networks and 3 instances - broker, server, client and issuer.\n$ docker network create choria_v2proto $ docker network create choria_issuer $ docker pull registry.choria.io/choria-nightly/choria:nightly $ docker run -ti --rm --entrypoint bash \\ --network choria_v2proto \\ --hostname broker.example.net \\ registry.choria.io/choria-nightly/choria:nightly -l $ docker run -ti --rm --entrypoint bash \\ --network choria_v2proto \\ --hostname server.example.net \\ registry.choria.io/choria-nightly/choria:nightly -l $ docker run -ti --rm --entrypoint bash \\ --network choria_v2proto \\ --hostname client.example.net \\ registry.choria.io/choria-nightly/choria:nightly -l $ docker run -ti --rm --entrypoint bash \\ --network choria_issuer \\ --hostname issuer.example.net registry.choria.io/choria-nightly/choria:nightly -l The issuer is not needed per-se but will demonstrate that the Issuer credentials never need to near the managed network.\nKeys and JWTs In this Scenario we need:\n An Organization Issuer keypair A client JWT for each user A server JWT for each server x509 certificate for the broker TLS port  In this scenario you are responsible for creating and distributing the keys and tokens.\nOrganization Issuer The Organization Issuer is the root of the Trust Chain and is a ed25519 key, let’s create the keypair on the issuer node:\n[choria@issuer ~]$ mkdir -p development/issuer [choria@issuer ~]$ choria jwt keys development/issuer/private.key development/issuer/public.key Public Key: b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 Ed25519 seed saved in development/issuer/private.key   Warning This key should be kept private and ideally in a Hashicorp Vault server. See a later section for guidance on Vault.\n  Broker JWT and Config Every broker needs a ed25519 Keypair and a signed JWT.\nFirst we create a keypair on the broker, the private key never leaves the broker:\n[choria@broker ~]$ choria jwt keys /etc/choria/private.key /etc/choria/public.key Public Key: 8918c1c7a4aeb4d4ad16729dc9b9c12df021d9296106eb5f072b224aa8f8eee9 Ed25519 seed saved in /etc/choria/private.key Pass the Public Key to the Organization Issuer who creates a JWT:\n[choria@issuer ~]$ mkdir -p development/broker/broker.example.net [choria@issuer ~]$ choria jwt server development/broker/broker.example.net/token.jwt \\ broker.example.net \\ 8918c1c7a4aeb4d4ad16729dc9b9c12df021d9296106eb5f072b224aa8f8eee9 \\ development/issuer/private.key \\ --collectives=choria With access to just the Broker public key the Organization Issuer can create a server token, pass this back to the server who stores it in /etc/choria/broker.jwt.\n Tip Note that for version 2 protocol the default collective is [\"choria\"].\n  [choria@issuer ~]$ choria jwt development/broker/broker.example.net/token.jwt development/issuer/public.key Validated Server Token development/server/server.example.net/token.jwt Identity: server.example.net Expires At: 2023-12-08 13:03:23 +0000 UTC (364d23h59m41s) Collectives: choria Public Key: 8918c1c7a4aeb4d4ad16729dc9b9c12df021d9296106eb5f072b224aa8f8eee9 Organization Unit: choria Private Network ID: 92328d88bef9d063480fd4b0ec5e4879 Broker Permissions: No server specific permissions granted We pass the JWT back to the broker and save in /etc/choria/broker.jwt.\nThe broker need x509 certificates to open the TLS network port, here we just self-sign one but you can get those from anywhere.\n[choria@broker ~]$ openssl genrsa -out /etc/choria/broker-tls.key 2048 Generating RSA private key, 2048 bit long modulus (2 primes) ..+++++ ....................................................................................................+++++ e is 65537 (0x010001) [choria@broker ~]$ openssl req -new -x509 -sha256 -key /etc/choria/broker-tls.key \\ -out /etc/choria/broker-tls.cert -days 365 -subj \"/O=Choria.io/CN=broker.example.net\" With all in place it should look like this:\n[choria@broker ~]$ find /etc/choria/ /etc/choria/ /etc/choria/broker.conf /etc/choria/broker-tls.key /etc/choria/broker-tls.cert /etc/choria/private.key /etc/choria/public.key /etc/choria/broker.jwt We create the broker configuration in /etc/choria/broker.conf and start it, you need to change your issuer here:\n# The name of the organization to configure, for now only supports choria plugin.security.issuer.names = choria # The public key from the issuer plugin.security.issuer.choria.public = b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 # Configures access to broker internal statistics and more plugin.choria.network.system.password = sYst3m # Used later in the Provisioner based setup plugin.choria.network.provisioning.client_password = s3cret plugin.choria.stats_port = 8222 plugin.choria.broker_network = true plugin.choria.network.client_port = 4222 plugin.choria.network.stream.store = /data plugin.choria.network.system.user = system loglevel = info plugin.choria.use_srv = false plugin.security.provider = choria plugin.security.choria.certificate = /etc/choria/broker-tls.cert plugin.security.choria.key = /etc/choria/broker-tls.key plugin.security.choria.token_file = /etc/choria/broker.jwt plugin.security.choria.seed_file = /etc/choria/private.key Let’s start the broker, showing the key lines from the output here:\n$ choria broker run --config /etc/choria/broker.conf INFO[0000] Choria Broker version 0.99.0.20221201 starting with config /etc/choria/broker.conf INFO[0000] Starting Network Broker WARN[0000] Allowing unverified TLS connections for Organization Issuer issued connections component=network WARN[0000] Loaded Organization Issuer choria with public key b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 component=network INFO[0000] Listening for client connections on [::]:4222 component=network_broker ... Server JWT Every server needs a ed25519 Keypair and a signed JWT.\nThe server process is identical to the broker process except change broker.example.net to server.example.net in identities and make obvious file name changes. Servers do not need any x509 certificates like brokers.\nNow we can configure and start the server, place this in /etc/choria/server.conf:\n# The name of the organization to configure, for now only supports choria plugin.security.issuer.names = choria # The public key from the issuer plugin.security.issuer.choria.public = b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 # We enable authorization and set it to trust the JWT tokens policy rpcauthorization = 1 rpcauthprovider = aaasvc plugin.security.provider = choria plugin.security.choria.token_file = /etc/choria/server.jwt plugin.security.choria.seed_file = /etc/choria/private.key plugin.choria.middleware_hosts = nats://broker.example.net:4222 And finally let’s run the server, showing key log lines only:\n Tip Servers usually run as root, here as the choria user as it’s in the container\n  [choria@server ~]$ choria server run --config /etc/choria/server.conf INFO[0000] Choria Server version 0.99.0.20221201 starting with config /etc/choria/server.conf using protocol version 2 INFO[0000] Setting JWT token and unique reply queues based on JWT for \"server.example.net\" component=server connection=server.example.net identity=server.example.net INFO[0000] Setting custom inbox prefix based on unique ID to choria.reply.77e64440ac709c0836487e5b77334e5b component=server connection=server.example.net identity=server.example.net Client JWT Every client needs a ed25519 keypair and a signed JWT.\nWe will create a client that has access to Choria Streams and the ability to manage the fleet without any AAA Server.\nThe client will create their own keypair, so we run that in the client node:\n[choria@client ~]$ mkdir -p ~/.config/choria/ [choria@client ~]$ choria jwt keys ~/.config/choria/private.key ~/.config/choria/public.key Public Key: 4bbfddb9f70f4b39f5b13bac8e83a9a31c3af49e388da86a666f8615101bc818 Ed25519 seed saved in /home/choria/.config/choria/private.key This client private.key should be kept private and not shared, the JWT can be created with knowledge of the public key only.\nThe client pass their Public Key to the Organization Issuer who creates a JWT on the Issuer node:\n Tip Here we use choria as the identity, this would match the unix user name.\nIf a user is on many machines, create a JWT per machine.\n  [choria@issuer ~]$ mkdir -p development/client/choria [choria@issuer ~]$ choria jwt client development/client/choria/token.jwt choria development/issuer/private.key \\ --public-key 4bbfddb9f70f4b39f5b13bac8e83a9a31c3af49e388da86a666f8615101bc818 \\ --stream-admin \\ --event-viewer \\ --elections-user \\ --service \\ --fleet-management \\ --agents '*' \\ --validity 1y Saved token to development/client/choria/token.jwt, use 'choria jwt view development/client/choria/token.jwt' to view it With access to the Issuer private key, but not the user private key, we can create a JWT for the user. Since we have no AAA Service we mark this user as a service which allows them to have a long token validity. We set a policy allowing all agent access, in real life this would be an Open Policy Agent policy.\n[choria@issuer ~]$ choria jwt development/client/choria/token.jwt development/issuer/public.key Validated Client Identification Token development/client/choria/token.jwt Caller ID: choria Organization Unit: choria Allowed Agents: * Public Key: 4bbfddb9f70f4b39f5b13bac8e83a9a31c3af49e388da86a666f8615101bc818 Private Network ID: 0a63c70a8817f5ef4d19d055ce6513f1 Expires At: 2023-12-08 12:54:07 +0000 UTC (364d23h59m19s) Client Permissions: Can manage Choria fleet nodes Can use Leader Elections Can view Lifecycle and Autonomous Agent events Can administer Choria Streams Can access the Broker system account Can have an extended token lifetime Pass the JWT back to the client who saves it in ~/.config/choria/token.jwt.\n[choria@client ~]$ find ~/.config /home/choria/.config /home/choria/.config/choria /home/choria/.config/choria/private.key /home/choria/.config/choria/public.key /home/choria/.config/choria/token.jwt We create a system-wide client configuration in /etc/choria/client.conf:\nloglevel = warn plugin.choria.middleware_hosts = broker.example.net:4222 plugin.choria.network.system.user = system plugin.choria.network.system.password = sYst3m plugin.security.provider = choria plugin.security.choria.token_file = ~/.config/choria/token.jwt plugin.security.choria.seed_file = ~/.config/choria/private.key We can now test the client:\n[choria@client ~]$ choria ping server.example.net time=3 ms ---- ping statistics ---- 1 replies max: 4ms min: 4ms avg: 4ms overhead: 12ms Other commands like choria req choria_util info should work demonstrating authorization works and choria broker server list should list the broker indicating Broker System Account access works. After a minute or so choria broker stream ls will show a list of Streams demonstrating Choria Streams authority worked.\nSelf Provisioned and AAA Integrated Deployment Thus far we had to manually sign and configure every single server and client, we had to copy files around and more, it’s all a bit tedious.\nLets see how Choria can configure itself and how user management can be centralized for self-service user enrollment.\n Instead of signing Server JWTs servers will go to Choria Provisioner to obtain credentials and configuration Instead of issuing Client JWTs for every user that are long-lasting we will use a central authorization flow to issue short-lived JWTs and distribute them    \nDocker We will create re-use the networks we made before, and we can keep the same issuer.example.net and broker.example.net.\nSo stop and recreate your server and client containers, we’ll 2 more container during the guide.\nIssuer The issuer is unchanged from before, so just follow the same steps as before or keep the one you have if you followed the Decentralized section.\nBroker The broker is unchanged from before, so just follow the same steps as before or keep the one you have if you followed the earlier Decentralized section.\nYou will note we have a setting in the broker.conf:\nplugin.choria.network.provisioning.client_password = s3cret This instructs the broker that we will be connecting servers needing provisioning to it. You should see a log line like:\nWARN[0000] Allowing Provisioner connections subject to JWT claims component=network Provisioner The Choria Provisioner is a service that configures new Choria Servers:\n Enrolls servers into the Issuer Create a per-node configuration Deploys Open Policy Agent policies Configures the server Optionally perform version upgrades  We have CLI tooling allowing you to re-provision servers on demand and more. Review its documentation for full detail.\nIt needs to connect to the broker, so it needs JWT token, let’s create the container and create the private key:\nSince the container does not have the choria command we have to jump some hoops, we’ll make a local storage directory for its configuration and keys and then mount that in.\nhost$ mkdir provisioner host$ docker run -v `pwd`/provisioner:/etc/choria-provisioner --user root --entrypoint bash --rm -ti registry.choria.io/choria-nightly/choria:nightly -l [root@5d96691fa69f /]# choria jwt keys /etc/choria-provisioner/private.key /etc/choria-provisioner/public.key Public Key: a8c15c0a4bbae0646d0c5aa92513f4d58c2c0e51464b4b267bb3a42dbebd1c8a [root@5d96691fa69f /]# chown -R choria:choria /etc/choria-provisioner/ [root@5d96691fa69f /]# exit Next we create a provisioner JWT and save it in provisioner/token.jwt\n[choria@issuer ~]$ mkdir -p development/provisioner [choria@issuer ~]$ choria jwt client development/provisioner/token.jwt provisioner_signer development/issuer/private.key \\ --public-key a8c15c0a4bbae0646d0c5aa92513f4d58c2c0e51464b4b267bb3a42dbebd1c8a \\ --server-provisioner \\ --validity 365d \\ --issuer Here we create a token that has access to the NATS Account new machines will join, it’s a year valid and it can issue new credentials.\nPlace the development/provisioner/token.jwt on your host in provisioner/token.jwt, next to private.key and public.key we made above.\n Tip We will not delve much into the Provisioner configuration details, visit its documentation site for details.\n  We need to configure how the Provisioner use these files, create provisioner/client.cfg on your host:\nplugin.security.provider = choria plugin.security.choria.token_file = /etc/choria-provisioner/token.jwt plugin.security.choria.seed_file = /etc/choria-provisioner/private.key  identity = provisioner_signer  plugin.choria.middleware_hosts = nats://broker.example.net:4222 Next we create the Provisioner configuration file in provisioner/choria-provisioner.yaml:\n# The issuer public key jwt_verify_cert: b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 interval: 1m logfile: /dev/stdout loglevel: info helper: /etc/choria-provisioner/helper.rb token: s3cret choria_insecure: false site: PREVIEW broker_provisioning_password: s3cret jwt_signing_key: private.key jwt_signing_token: token.jwt  features:  jwt: true  ed25519: true Next we need the script that generates per-node configuration, store the helper.rb in provisioner/helper.rb and change the ISSUER constant near the top.\nhost$ vi provisioner/helper.rb host$ chmod a+x provisioner/helper.rb host$ sudo chown -R 2048:2048 provisioner We can now run our Provisioner:\nhost$ docker run -ti --rm -v `pwd`/provisioner:/etc/choria-provisioner \\ --network choria_v2proto \\ --hostname provisioner.example.net \\ choria/provisioner:nightly Servers For servers, we are going to need the RPM (already in the container) and a new file /etc/choria/provisioning.jwt. This is read by the server process and tells it to enter provisioning mode.\nThe JWT file is basically just a configuration file signed by our Issuer. The server reads it unvalidated but the Provisioner will ensure the incoming server holds the token signed by our Issuer.\n[choria@issuer ~]$ choria jwt prov development/server/provisioning.jwt \\ development/issuer/private.key \\ --token s3cret \\ --urls nats://broker.example.net:4222 \\ --protocol-v2 \\ --default Saved token to development/server/provisioning.jwt, use 'choria jwt view development/server/provisioning.jwt' to view it [choria@issuer ~]$ choria jwt development/server/provisioning.jwt Unvalidated Provisioning Token development/server/provisioning.jwt Token: ***** Secure: false URLS: nats://broker.example.net:4222 Provisioning by default: true Using version 2 Protocol: true Server Version Upgrades: false Standard Claims: { \"purpose\": \"choria_provisioning\", \"iss\": \"Choria Tokens Package v0.99.0.20221210\", \"sub\": \"choria_provisioning\", \"nbf\": 1670850426, \"iat\": 1670850426, \"jti\": \"60a2973b10304184b997f9ea50eeb7a4\" } Copy this to your host before running the server. We need to mount this token into the server containers, no other configuration is needed:\nhost$ docker run -ti --rm \\ --network choria_v2proto \\ --hostname server.example.net \\ -v `pwd`/provisioning.jwt:/etc/choria/provisioning.jwt \\ registry.choria.io/choria-nightly/choria:nightly server run --config /etc/choria/server.conf The server will now start and connect to the Broker, communicate with the Provisioner and restart itself. After restart the client (configured next) will be able to communicate with it.\nPreviously we had to use choria jwt keys and choria jwt server to create Private keys and to issue a signed JWT and then manually transfer that to the Server and configure the Server. This all happens under Choria Provisioner control and takes just a few milliseconds. The only site-unique part about a machine is now the provisioner.jwt that is shared by your fleet, so it’s easily placed there during base image build or configuration management. You could issue node-unique provisioning.jwt files with extended information in them and in your helper.rb perform additional validation if you needed that much control.\nAAA Service To provide a self-service system for Clients configure the Choria AAA Service. Here we will configure it to both issue JWTs and Sign individual requests - meaning it’s required to be available for every RPC request. The signing part is optional though, and we could skip that, using it only to obtain JWT tokens.\n Tip We will not delve much into the AAA Service configuration details, visit its documentation site for details.\n  We need to issue 3 sets of credentials here:\n One to sign users who request their JWT using choria login called the Chain Signer, since this is HTTP it also needs a x509 certificate One to sign RPC requests on behalf of users after evaluating policies and auditing requests called the Request Signer One to connect to Choria Broker with and run a Choria RPC Service that will receive requests from users to sign their requests called a Signer Service.  Like the Provisioner the AAA Service container does not have the choria binary, so we need to jump some hoops to make the keys and configuration:\nhost$ docker run -ti --rm -v `pwd`/aaasvc:/etc/aaasvc --user root --entrypoint bash registry.choria.io/choria-nightly/choria:nightly -l [root@38f75c90e475 /]# openssl genrsa -out /etc/aaasvc/https-private.key 2048 Generating RSA private key, 2048 bit long modulus (2 primes) ........................................................................................+++++ ...................................+++++ [root@38f75c90e475 /]# openssl req -new -x509 -sha256 -key /etc/aaasvc/https-private.key -out /etc/aaasvc/https-public.crt -days 365 -subj \"/O=Choria.io/CN=aaa.choria.local\" [root@38f75c90e475 /]# choria jwt keys /etc/aaasvc/chain-signer-private.key /etc/aaasvc/chain-signer-public.key Public Key: 17807f2c5fa959383ee5851813863426525c081f6464556e5dec482e815caded Ed25519 seed saved in /etc/aaasvc/chain-signer-private.key We create a self-signed x509 certificate since the Authentication service runs over HTTPS, you can use any certificate for this.\nFurther we create a key used to sign JWTs for users running choria login, it needs a special JWT:\n[choria@issuer ~]$ mkdir -p development/aaasvc [choria@issuer ~]$ choria jwt client development/aaasvc/chain-signer.jwt aaa_chain_signer \\ development/issuer/private.key \\ --public-key 17807f2c5fa959383ee5851813863426525c081f6464556e5dec482e815caded \\ --no-fleet-management \\ --issuer \\ --validity 365d Saved token to client development/aaasvc/chain-signer.jwt, use 'choria jwt view client development/aaasvc/chain-signer.jwt' to view it Copy this file to the temporary AAA container above as /etc/aaasvc/chain-signer.jwt.\nNext we create the credentials that will sign every RPC request:\nhost$ docker run -ti --rm -v `pwd`/aaasvc:/etc/aaasvc --user root --entrypoint bash registry.choria.io/choria-nightly/choria:nightly -l [root@38f75c90e475 /]# choria jwt keys /etc/aaasvc/request-signer-private.key /etc/aaasvc/reqeuest-signer-public.key Public Key: 535e9d337e555b9bf9079269567b8d9cb812fdf54797e5d5441ed778f1db68d8 Ed25519 seed saved in /etc/aaasvc/request-signer-private.key This is the key used to sign individual user RPC requests on their behalf, it needs a special JWT:\n[choria@issuer ~]$ mkdir -p development/aaasvc [choria@issuer ~]$ choria jwt client development/aaasvc/request-signer.jwt aaa_request_signer \\ development/issuer/private.key \\ --public-key 535e9d337e555b9bf9079269567b8d9cb812fdf54797e5d5441ed778f1db68d8 \\ --no-fleet-management \\ --auth-delegation \\ --validity 365d Saved token to development/aaasvc/request-signer.jwt, use 'choria jwt view development/aaasvc/request-signer.jwt' to view it Place it in /etc/aaasvc/request-signer.jwt on the AAA Service container above.\nFinally, we need to create the credentials that allow the request signer to run as a Choria Service.\nhost$ docker run -ti --rm -v `pwd`/aaasvc:/etc/aaasvc --user root --entrypoint bash registry.choria.io/choria-nightly/choria:nightly -l [root@38f75c90e475 /]# choria jwt keys /etc/aaasvc/signer-service-private.key /etc/aaasvc/signer-service-public.key Public Key: c5c1323f66bb8324d019249e3476d9f11f9deb70efa60255593dde30ef3b8a01 Ed25519 seed saved in /etc/aaasvc/signer-service-private.key Let’s create the server JWT that will host the RPC Service for signing requests\n[choria@issuer ~]$ choria jwt server development/aaasvc/signer-service.jwt \\ aaa.example.net \\ c5c1323f66bb8324d019249e3476d9f11f9deb70efa60255593dde30ef3b8a01 \\ development/issuer/private.key \\ --org choria \\ --collectives choria \\ --service \\ --validity 365d Place it in /etc/aaasvc/signer-service.jwt on the AAA Service container above.\nWe can now configure the various parts of the AAA Service, it needs a /etc/aaasvc/choria.conf to connect to the network with:\nidentity = aaa.example.net plugin.security.provider = choria plugin.security.choria.seed_file = /etc/aaasvc/signer-service-private.key plugin.security.choria.token_file = /etc/aaasvc/signer-service.jwt plugin.choria.middleware_hosts = broker.example.net:4222 We need an /etc/aaasvc/aaasvc.conf:\n Tip See the User List Authenticator docs about user, passwords and more. The passwords below are all secret.\n  {  \"choria_config\": \"/etc/aaasvc/choria.conf\",  \"logfile\": \"/dev/stdout\",  \"loglevel\": \"info\",  \"authenticator\": \"userlist\",  \"authorizer\": \"opa\",  \"signer\": \"basicjwt\",  \"monitor_port\": 8081,  \"site\": \"PREVIEW\",  \"tls_certificate\": \"/etc/aaasvc/https-public.crt\",  \"tls_key\":\"/etc/aaasvc/https-private.key\",  \"port\":8080,  \"basicjwt_signer\": {  \"signing_certificate\": \"/etc/aaasvc/chain-signer-public.key\",  \"signing_token\": \"/etc/aaasvc/request-signer.jwt\",  \"signing_seed\": \"/etc/aaasvc/request-signer-private.key\",  \"max_validity\":\"2h\",  \"choria_service\": true  },  \"userlist_authenticator\": {  \"signing_key\": \"/etc/aaasvc/chain-signer-private.key\",  \"signing_token\": \"/etc/aaasvc/chain-signer.jwt\",  \"validity\": \"1h\",  \"users\": [  {  \"username\": \"admin\",  \"password\": \"$2a$05$zQIl4gUZbqmKhpQhIeWx3uDWhAZaHoG34zW1ZsxXQt5xpL5f4uyny\",  \"opa_policy_file\": \"/etc/aaasvc/admin.rego\",  \"broker_permissions\": {  \"org_admin\": true,  \"system_user\": true,  \"signed_fleet_management\": true  }  },  {  \"username\": \"streams\",  \"password\": \"$2a$05$zQIl4gUZbqmKhpQhIeWx3uDWhAZaHoG34zW1ZsxXQt5xpL5f4uyny\",  \"broker_permissions\": {  \"streams_admin\": true  }  },  {  \"username\": \"choria\",  \"password\": \"$2a$05$zQIl4gUZbqmKhpQhIeWx3uDWhAZaHoG34zW1ZsxXQt5xpL5f4uyny\",  \"opa_policy_file\": \"/etc/aaasvc/admin.rego\",  \"broker_permissions\": {  \"signed_fleet_management\": true  }  }  ]  } }   Warning See the AAA Service Docs for writing real policies.\n  Finally, we create an Open Policy Agent policy for the Choria Users, this one just allows everything. Place it in /etc/aaasvc/admin.rego\npackage io.choria.aaasvc default allow = true We can now start the AAA Service:\nhost$ sudo chown -R 2048:2048 aaasvc host$ docker run -ti --rm \\ -v `pwd`/aaasvc:/etc/aaasvc \\ --network choria_v2proto \\ --hostname aaa.example.net \\ choria/aaasvc:nightly run --config /etc/aaasvc/aaasvc.conf Client Choria Clients will now enroll using choria login which will issue them a 1-hour valid JWT with their policies and more embedded.\nLets create a new client container:\n$ docker run -ti --rm --entrypoint bash \\ --network choria_v2proto \\ --hostname client.example.net \\ registry.choria.io/choria-nightly/choria:nightly -l We create a system-wide client configuration in /etc/choria/client.conf:\nloglevel = warn plugin.choria.middleware_hosts = broker.example.net:4222 plugin.choria.network.system.user = system plugin.choria.network.system.password = sYst3m plugin.security.provider = choria plugin.security.choria.token_file = ~/.config/choria/client.jwt plugin.security.choria.seed_file = ~/.config/choria/client.key plugin.choria.security.request_signer.service = true plugin.login.aaasvc.login.url = https://aaa.example.net:8080/choria/v1/login Users can now run choria login and authenticate using on of the usernames and the password secret.\nThe client is now entirely self-service, the token expires every hour, and they just run choria login again. They can do this on as many machines as they have and admins do not get involved.\nEvery RPC request the client makes will be signed by the AAA Service after Authorization against the OPA Policy and auditing the outcome. Servers will also validate the OPA policy before executing anything.\nVault as Organization Issuer We support using Hashicorp Vault as the Organization Issuer. In that mode the Private Key is created inside Vault and never has to leave Vault at all.\n Warning Here we’ll show the developer mode Vault you should use a Production deployment of Vault and not a simple developer local build.\n  Starting Vault We start Vault in dev mode with a static secret defined:\n$ vault server -dev -dev-root-token-id root ==\u003e Vault server configuration: Api Address: http://127.0.0.1:8200 Cgo: disabled Cluster Address: https://127.0.0.1:8201 .... WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory and starts unsealed with a single unseal key. The root token is already authenticated to the CLI, so you can immediately begin using Vault. You may need to set the following environment variables: $ export VAULT_ADDR='http://127.0.0.1:8200' The unseal key and root token are displayed below in case you want to seal/unseal the Vault or re-authenticate. Unseal Key: JKyF70iBqv3d9rreY9rhY0/EQ9ornriTZHV+kVWpJ+w= Root Token: root Development mode should NOT be used in production installations! Configuring the Transit Secrets Engine Choria relies on the Transit Secrets Engine to offload signing of keys.\nLet’s enable that:\n$ export VAULT_ADDR='http://127.0.0.1:8200 $ export VAULT_TOKEN='root' $ vault secrets enable transit Success! Enabled the transit secrets engine at: transit/ Create the Issuer We use the Vault API to create an ed25519 key stored in Vault storage:\n$ export VAULT_ADDR='http://127.0.0.1:8200 $ export VAULT_TOKEN='root' $ vault write transit/keys/choria_issuer type=ed25519 Success! Data written to: transit/keys/choria_issuer $ vault read transit/keys/choria_issuer Key Value --- ----- allow_plaintext_backup false auto_rotate_period 0s deletion_allowed false derived false exportable false imported_key false keys map[1:map[creation_time:2022-12-12T11:21:23.248802439+01:00 name:ed25519 public_key:IZu6TyYAwWeuyD3Q0tEiCGbYBjkRjoOcWO/OI9PDmOE=]] latest_version 1 min_available_version 0 min_decryption_version 1 min_encryption_version 0 name choria_issuer supports_decryption false supports_derivation true supports_encryption false supports_signing true type ed25519 Here we see that the public key is shown as public_key:IZu6TyYAwWeuyD3Q0tEiCGbYBjkRjoOcWO/OI9PDmOE=, lets turn that into a hex encoded string:\n Tip If saving the public key to a file ensure there is no trailing new line\n  $ echo IZu6TyYAwWeuyD3Q0tEiCGbYBjkRjoOcWO/OI9PDmOE=|base64 -d|xxd -p -c 64 219bba4f2600c167aec83dd0d2d1220866d80639118e839c58efce23d3c398e1 This is the Organization Issuer you configure in your broker and elsewhere.\nSigning JWTs using Vault The choria jwt commands support the --vault flag that requires VAULT_ADDR and VAULT_TOKEN to be set in environment.\n$ choria jwt server \\ token.jwt \\ server.example.net \\ 3f2d5d01f3c5caa0cd7359512c7e2d9a727fa0392f47f50adee1866bf02cbe12 \\ choria_issuer \\ --collectives=choria \\ --vault Here we pass --vault and instead of a path to the Issuer Private Key we give the name choria_issuer that we created in Vault.\n","description":"","tags":null,"title":"V2 Protocol \u0026 Security","uri":"/previews/protov2/index.html"},{"content":"Choria Server is the component that runs on every managed device. It hosts various plugins that can be accessed remotely via a RPC layer.\nIt’s a stable and robust agent designed to run forever with minimal resource overheads on managed devices.\nFeatures  Hosts Choria RPC Agents Hosts Choria Autonomous Agents Hosts foundational technology for Choria Scout Supports optional self-provisioning and enrollment into a Choria network in a IoT device like manner Communicates using a JSON based network protocol with extensive JSON Schemas Deep RBAC integration for Authentication, Authorization and Auditing Supports mTLS or JWT token based security layers with, optional, integration into Enterprise SSO, IAM and systems like Hashicorp Vault Supports Open Policy Agent for Authorization Emits Cloud Events for network management and observability Embeddable in Go applications to provide in-process management for automation backplanes Extensive features related to gathering and streaming of Node Metadata Distributed as RPM, Deb, DMG, MSI across many architectures  ","description":"","tags":null,"title":"Choria Server","uri":"/server/index.html"},{"content":"We distribute an RPM, Debs, MSIs, Exes and Docker containers for the Choria Server and Broker.\nEnterprise Linux We publish RPM releases but also nightly builds to our repositories.\nUsers of our Puppet modules will already have these repositories available.\nRelease [choria_release] name=Choria Orchestrator Releases mirrorlist=http://mirrorlists.choria.io/yum/release/el/$releasever/$basearch.txt enabled=True gpgcheck=True repo_gpgcheck=True gpgkey=https://choria.io/RELEASE-GPG-KEY metadata_expire=300 sslcacert=/etc/pki/tls/certs/ca-bundle.crt sslverify=True Nightly Nightly releases are named and versioned choria-0.99.0.20221109-1.el7.x86_64.rpm where the last part of the version is the date.\n[choria_nightly] name=Choria Orchestrator Nightly mirrorlist=http://mirrorlists.choria.io//yum/nightly/el/$releasever/$basearch.txt enabled=True gpgcheck=True repo_gpgcheck=True gpgkey=https://choria.io/NIGHTLY-GPG-KEY metadata_expire=300 sslcacert=/etc/pki/tls/certs/ca-bundle.crt sslverify=True Debian We publish release packages for Debian systems on our APT repositories:\ndeb mirror://mirrorlists.choria.io/apt/release/debian/bullseye/mirrors.txt debian bullseye Docker There is a docker container for releases registry.choria.io/choria/choria:latest with nightly builds at registry.choria.io/choria-nightly/choria with tags nightly and nightly-YYYYMMDD.\n","description":"","tags":null,"title":"Installation","uri":"/installation/index.html"},{"content":"This is a list of all known Configuration settings. This list is based on declared settings within the Choria Go code base and so will not cover 100% of settings - plugins can contribute their own settings which are note known at compile time.\n Version Hint Built on 22 Mar 23 08:52 UTC using version 0.27.0\n  Run-time configuration The run-time configuration can be inspected using choria tool config --config /etc/choria/server.cfg, this will show the active configuration.\nSearch and list directives In addition to the full list below you can get configuration information for your version using the CLI:\n% choria tool config security.provider .... Configuration item: plugin.security.provider ║ Value: puppet ║ Data Type: string ║ Validation: enum=puppet,file,pkcs11,certmanager,choria ║ Default: puppet ║ ║ The Security Provider to use ╙─ Data Types A few special types are defined, the rest map to standard Go types\n   Type Description     comma_split A comma separated list of strings, possibly with spaces between   duration A duration such as 1h, 300ms, -1.5h or 2h45m. Valid time units are ns, ms, s, m, h   path_split A list of paths split by a OS specific PATH separator   path_string A path that can include ~ for the users home directory   strings A space separated list of strings   title_string A string that will be stored as a Title String    Index          classesfile collectives   color default_discovery_method   default_discovery_options discovery_timeout   identity libdir   logfile loglevel   main_collective plugin.choria.adapters   plugin.choria.agent_provider.mcorpc.agent_shim plugin.choria.agent_provider.mcorpc.config   plugin.choria.agent_provider.mcorpc.libdir plugin.choria.broker_federation   plugin.choria.broker_network plugin.choria.discovery.broadcast.windowed_timeout   plugin.choria.discovery.external.command plugin.choria.discovery.inventory.source   plugin.choria.federation.cluster plugin.choria.federation.collectives   plugin.choria.federation_middleware_hosts plugin.choria.legacy_lifecycle_format   plugin.choria.machine.signing_key plugin.choria.machine.store   plugin.choria.middleware_hosts plugin.choria.network.client_hosts   plugin.choria.network.client_port plugin.choria.network.client_signer_cert   plugin.choria.network.client_tls_force_required plugin.choria.network.deny_server_connections   plugin.choria.network.gateway_name plugin.choria.network.gateway_port   plugin.choria.network.gateway_remotes plugin.choria.network.leafnode_port   plugin.choria.network.leafnode_remotes plugin.choria.network.listen_address   plugin.choria.network.mapping.names plugin.choria.network.peer_password   plugin.choria.network.peer_port plugin.choria.network.peer_user   plugin.choria.network.peers plugin.choria.network.pprof_port   plugin.choria.network.provisioning.client_password plugin.choria.network.provisioning.provisioner_without_token   plugin.choria.network.provisioning.signer_cert plugin.choria.network.public_url   plugin.choria.network.server_signer_cert plugin.choria.network.stream.advisory_replicas   plugin.choria.network.stream.advisory_retention plugin.choria.network.stream.event_replicas   plugin.choria.network.stream.event_retention plugin.choria.network.stream.leader_election_replicas   plugin.choria.network.stream.leader_election_ttl plugin.choria.network.stream.machine_replicas   plugin.choria.network.stream.machine_retention plugin.choria.network.stream.manage_streams   plugin.choria.network.stream.store plugin.choria.network.system.password   plugin.choria.network.system.user plugin.choria.network.tls_timeout   plugin.choria.network.websocket_advertise plugin.choria.network.websocket_port   plugin.choria.network.write_deadline plugin.choria.prometheus_textfile_directory   plugin.choria.puppetca_host plugin.choria.puppetca_port   plugin.choria.puppetdb_host plugin.choria.puppetdb_port   plugin.choria.puppetserver_host plugin.choria.puppetserver_port   plugin.choria.registration.file_content.compression plugin.choria.registration.file_content.data   plugin.choria.registration.file_content.target plugin.choria.registration.inventory_content.compression   plugin.choria.registration.inventory_content.target plugin.choria.require_client_filter   plugin.choria.security.certname_whitelist plugin.choria.security.privileged_users   plugin.choria.security.request_signer.seed_file plugin.choria.security.request_signer.service   plugin.choria.security.request_signer.token_file plugin.choria.security.request_signer.url   plugin.choria.security.server.seed_file plugin.choria.security.server.token_file   plugin.choria.server.provision plugin.choria.server.provision.allow_update   plugin.choria.services.registry.cache plugin.choria.services.registry.store   plugin.choria.srv_domain plugin.choria.ssldir   plugin.choria.stats_address plugin.choria.stats_port   plugin.choria.status_file_path plugin.choria.status_update_interval   plugin.choria.submission.max_spool_size plugin.choria.submission.spool   plugin.choria.use_srv plugin.login.aaasvc.login.url   plugin.nats.credentials plugin.nats.pass   plugin.nats.user plugin.scout.agent_disabled   plugin.scout.goss.denied_local_resources plugin.scout.goss.denied_remote_resources   plugin.scout.overrides plugin.scout.tags   plugin.security.certmanager.alt_names plugin.security.certmanager.api_version   plugin.security.certmanager.issuer plugin.security.certmanager.namespace   plugin.security.certmanager.replace plugin.security.choria.ca   plugin.security.choria.certificate plugin.security.choria.key   plugin.security.choria.seed_file plugin.security.choria.sign_replies   plugin.security.choria.token_file plugin.security.choria.trusted_signers   plugin.security.cipher_suites plugin.security.client_anon_tls   plugin.security.ecc_curves plugin.security.file.ca   plugin.security.file.certificate plugin.security.file.key   plugin.security.issuer.names plugin.security.pkcs11.driver_file   plugin.security.pkcs11.slot plugin.security.provider   plugin.security.server_anon_tls plugin.security.support_legacy_certificates   plugin.yaml registerinterval   registration registration_collective   registration_splay rpcaudit   rpcauthorization rpcauthprovider   rpclimitmethod soft_shutdown_timeout   ttl     classesfile  Type: path_string Default Value: /opt/puppetlabs/puppet/cache/state/classes.txt  Path to a file listing configuration classes applied to a node, used in matches using Class filters\ncollectives  Type: comma_split  The list of known Sub Collectives this node will join or communicate with, Servers will subscribe the node and each agent to each sub collective and Clients will publish to a chosen sub collective. Defaults to the build settin build.DefaultCollectives\ncolor  Type: boolean Default Value: true  Disables or enable CLI color\ndefault_discovery_method  Type: string Validation: enum=mc,broadcast,puppetdb,choria,external,inventory Default Value: mc  The default discovery plugin to use. The default “mc” uses a network broadcast, “choria” uses PuppetDB, external calls external commands\ndefault_discovery_options  Type: strings  Default options to pass to the discovery plugin\ndiscovery_timeout  Type: integer Default Value: 2  How long to wait for responses while doing broadcast discovery\nidentity  Type: string  The identity this machine is known as, when empty it’s derived based on the operating system hostname or by calling facter fqdn\nlibdir  Type: path_split  The directory where Agents, DDLs and other plugins are found\nlogfile  Type: path_string Default Value: stdout  The file to write logs to, when set to ‘discard’ logging will be disabled. Also supports ‘stdout’ and ‘stderr’ as special log destinations.\nloglevel  Type: string Validation: enum=debug,info,warn,error,fatal Default Value: info  The lowest level log to add to the logfile\nmain_collective  Type: string  The Sub Collective where a Client will publish to when no specific Sub Collective is configured\nplugin.choria.adapters  Type: comma_split Additional Information: https://choria.io/docs/adapters/  The list of Data Adapters to activate\nplugin.choria.agent_provider.mcorpc.agent_shim  Type: string  Path to the helper used to call MCollective Ruby agents\nplugin.choria.agent_provider.mcorpc.config  Type: string  Path to the MCollective configuration file used when running MCollective Ruby agents\nplugin.choria.agent_provider.mcorpc.libdir  Type: path_split  Path to the libdir MCollective Ruby agents should have\nplugin.choria.broker_federation  Type: boolean Additional Information: https://choria.io/docs/federation/ Default Value: false  Enables the Federation Broker\nplugin.choria.broker_network  Type: boolean Additional Information: https://choria.io/docs/deployment/broker/ Default Value: false  Enables the Network Broker\nplugin.choria.discovery.broadcast.windowed_timeout  Type: boolean  Enables the experimental dynamic timeout for choria/mc discovery\nplugin.choria.discovery.external.command  Type: path_string  The command to use for external discovery\nplugin.choria.discovery.inventory.source  Type: path_string  The file to read for inventory discovery\nplugin.choria.federation.cluster  Type: string Additional Information: https://choria.io/docs/federation/ Default Value: mcollective  The cluster name a Federation Broker serves\nplugin.choria.federation.collectives  Type: comma_split Additional Information: https://choria.io/docs/federation/ Environment Variable: CHORIA_FED_COLLECTIVE  List of known remote collectives accessible via Federation Brokers\nplugin.choria.federation_middleware_hosts  Type: comma_split Additional Information: https://choria.io/docs/federation/  Middleware brokers used by the Federation Broker, if unset uses SRV\nplugin.choria.legacy_lifecycle_format  Type: boolean Default Value: 0  When enabled will publish lifecycle events in the legacy format, else Cloud Events format is used\nplugin.choria.machine.signing_key  Type: string  Public key used to sign data for watchers like machines watcher. Will override the value compiled in or in the watcher definitions if set here. This is primarily to allow development environments to use different private keys.\nplugin.choria.machine.store  Type: string Additional Information: https://choria.io/docs/autoagents/  Directory where Autonomous Agents are stored\nplugin.choria.middleware_hosts  Type: comma_split  Set specific middleware hosts in the format host:port, if unset uses SRV\nplugin.choria.network.client_hosts  Type: comma_split  CIDRs to limit client connections from, appropriate ACLs are added based on this\nplugin.choria.network.client_port  Type: integer Additional Information: https://choria.io/docs/deployment/broker/ Default Value: 4222  Port the Network Broker will accept client connections on\nplugin.choria.network.client_signer_cert  Type: comma_split  Fully qualified paths to the public certificates used by the AAA Service to sign client JWT tokens. This enables users with signed JWTs to use unverified TLS to connect. Can also be a list of ed25519 public keys.\nplugin.choria.network.client_tls_force_required  Type: boolean  Force requiring/not requiring TLS for all clients\nplugin.choria.network.deny_server_connections  Type: boolean  Set ACLs denying server connections to this broker\nplugin.choria.network.gateway_name  Type: string Default Value: CHORIA  Name for the Super Cluster\nplugin.choria.network.gateway_port  Type: integer Default Value: 0  Port to listen on for Super Cluster connections\nplugin.choria.network.gateway_remotes  Type: comma_split  List of remote Super Clusters to connect to\nplugin.choria.network.leafnode_port  Type: integer Default Value: 0  Port to listen on for Leafnode connections, disabled with 0\nplugin.choria.network.leafnode_remotes  Type: comma_split  Remote networks to connect to as a Leafnode\nplugin.choria.network.listen_address  Type: string Additional Information: https://choria.io/docs/deployment/broker/ Default Value: ::  Address the Network Broker will listen on\nplugin.choria.network.mapping.names  Type: comma_split  List of subject remappings to apply\nplugin.choria.network.peer_password  Type: string  Password to use when connecting to cluster peers\nplugin.choria.network.peer_port  Type: integer Additional Information: https://choria.io/docs/deployment/broker/  Port used to communicate with other local cluster peers\nplugin.choria.network.peer_user  Type: string  Username to use when connecting to cluster peers\nplugin.choria.network.peers  Type: comma_split Additional Information: https://choria.io/docs/deployment/broker/  List of cluster peers in host:port format\nplugin.choria.network.pprof_port  Type: integer Default Value: 0  The port the network broker will listen on for pprof requests\nplugin.choria.network.provisioning.client_password  Type: string  Password the provisioned clients should use to connect\nplugin.choria.network.provisioning.provisioner_without_token  Type: boolean  Allows a provisioner without a token to connect over TLS using username and password. This facilitates v1 provisioning on an Issuer based network\nplugin.choria.network.provisioning.signer_cert  Type: path_string  Path to the public cert that signs provisioning tokens, enables accepting provisioning connections into the provisioning account\nplugin.choria.network.public_url  Type: string  Name:Port to advertise to clients, useful when fronted by a proxy\nplugin.choria.network.server_signer_cert  Type: comma_split  Fully qualified Paths to the public certificates used by the Provisioner Service to sign server JWT tokens. This enables servers with signed JWTs to use unverified TLS to connect. Can also be a list of ed25519 public keys.\nplugin.choria.network.stream.advisory_replicas  Type: integer Default Value: -1  When configuring Stream advisories storage ensure data is replicated in the cluster over this many servers, -1 means count of peers\nplugin.choria.network.stream.advisory_retention  Type: duration Default Value: 168h  When not zero enables retaining Stream advisories in the Stream Store\nplugin.choria.network.stream.event_replicas  Type: integer Default Value: -1  When configuring LifeCycle events ensure data is replicated in the cluster over this many servers, -1 means count of peers\nplugin.choria.network.stream.event_retention  Type: duration Default Value: 24h  When not zero enables retaining Lifecycle events in the Stream Store\nplugin.choria.network.stream.leader_election_replicas  Type: integer Default Value: -1  When configuring Stream based Leader Election storage ensure data is replicated in the cluster over this many servers, -1 means count of peers\nplugin.choria.network.stream.leader_election_ttl  Type: duration Default Value: 1m  The TTL for leader election, leaders must vote at least this frequently to remain leader\nplugin.choria.network.stream.machine_replicas  Type: integer Default Value: -1  When configuring Autonomous Agent event storage ensure data is replicated in the cluster over this many servers, -1 means count of peers\nplugin.choria.network.stream.machine_retention  Type: duration Default Value: 24h  When not zero enables retaining Autonomous Agent events in the Stream Store\nplugin.choria.network.stream.manage_streams  Type: boolean Default Value: 1  When set to zero will disable managing the standard streams on this node\nplugin.choria.network.stream.store  Type: path_string  Enables Streaming data persistence stored in this path\nplugin.choria.network.system.password  Type: string  Password used to access the Choria system account\nplugin.choria.network.system.user  Type: string  Username used to access the Choria system account\nplugin.choria.network.tls_timeout  Type: integer Default Value: 2  Time to allow for TLS connections to establish, increase on slow or very large networks\nplugin.choria.network.websocket_advertise  Type: string Additional Information: https://choria.io/docs/deployment/broker/  The URL to advertise for websocket connections\nplugin.choria.network.websocket_port  Type: integer Additional Information: https://choria.io/docs/deployment/broker/  Port to listen on for websocket connections\nplugin.choria.network.write_deadline  Type: duration Default Value: 10s  How long to allow clients to process traffic before treating them as slow, increase this on large networks or slow networks\nplugin.choria.prometheus_textfile_directory  Type: path_string  Directory where Prometheus Node Exporter textfile collector reads data\nplugin.choria.puppetca_host  Type: string Default Value: puppet  The hostname where your Puppet Certificate Authority can be found\nplugin.choria.puppetca_port  Type: integer Default Value: 8140  The port your Puppet Certificate Authority listens on\nplugin.choria.puppetdb_host  Type: string  The host hosting your PuppetDB, used by the “choria” discovery plugin\nplugin.choria.puppetdb_port  Type: integer Default Value: 8081  The port your PuppetDB listens on\nplugin.choria.puppetserver_host  Type: string Default Value: puppet  The hostname where your Puppet Server can be found\nplugin.choria.puppetserver_port  Type: integer Default Value: 8140  The port your Puppet Server listens on\nplugin.choria.registration.file_content.compression  Type: boolean Default Value: true  Enables gzip compression of registration data\nplugin.choria.registration.file_content.data  Type: string  YAML or JSON file to use as data source for registration\nplugin.choria.registration.file_content.target  Type: string  NATS Subject to publish registration data to\nplugin.choria.registration.inventory_content.compression  Type: boolean Default Value: true  Enables gzip compression of registration data\nplugin.choria.registration.inventory_content.target  Type: string  NATS Subject to publish registration data to\nplugin.choria.require_client_filter  Type: boolean Default Value: false  If a client filter should always be required, only used in Go clients\nplugin.choria.security.certname_whitelist  Type: comma_split Default Value: .mcollective$,.choria$  Patterns of certificate names that are allowed to be clients\nplugin.choria.security.privileged_users  Type: comma_split Additional Information: https://choria.io/docs/configuration/aaa/ Default Value: .privileged.mcollective$,.privileged.choria$  Patterns of certificate names that would be considered privileged and able to set custom callers\nplugin.choria.security.request_signer.seed_file  Type: path_string Additional Information: https://github.com/choria-io/aaasvc  Path to the seed file used to access a Central Authenticator\nplugin.choria.security.request_signer.service  Type: boolean Additional Information: https://choria-io.github.io/aaasvc/  Enables signing requests via Choria RPC requests\nplugin.choria.security.request_signer.token_file  Type: path_string Additional Information: https://github.com/choria-io/aaasvc  Path to the token used to access a Central Authenticator\nplugin.choria.security.request_signer.url  Type: string Additional Information: https://choria-io.github.io/aaasvc/  URL to the Signing Service\nplugin.choria.security.server.seed_file  Type: path_string  The server token seed to use for authentication, defaults to server.seed in the same location as server.conf\nplugin.choria.security.server.token_file  Type: path_string  The server token file to use for authentication, defaults to serer.jwt in the same location as server.conf\nplugin.choria.server.provision  Type: boolean Additional Information: https://choria-io.github.io/provisioner/ Default Value: false  Specifically enable or disable provisioning\nplugin.choria.server.provision.allow_update  Type: boolean Additional Information: https://choria-io.github.io/provisioner/ Default Value: false  Allows the provisioner to perform in-place version updates\nplugin.choria.services.registry.cache  Type: path_string Environment Variable: CHORIA_REGISTRY  Directory where the Registry client stores DDLs found in the registry\nplugin.choria.services.registry.store  Type: path_string  Directory where the Registry service finds DDLs to read\nplugin.choria.srv_domain  Type: string Additional Information: https://choria.io/docs/deployment/dns/  The domain to use for SRV records, defaults to the domain the server FQDN is in\nplugin.choria.ssldir  Type: path_string  The SSL directory, auto detected via Puppet, when specifically set Puppet will not be consulted\nplugin.choria.stats_address  Type: string Default Value: 127.0.0.1  The address to listen on for statistics\nplugin.choria.stats_port  Type: integer Default Value: 0  The port to listen on for HTTP requests for statistics, setting to 0 disables it\nplugin.choria.status_file_path  Type: path_string  Path to a JSON file to write server health information to regularly\nplugin.choria.status_update_interval  Type: integer Default Value: 30  How frequently to write to the status_file_path\nplugin.choria.submission.max_spool_size  Type: integer Default Value: 500  Maximum amount of messages allowed into each priority\nplugin.choria.submission.spool  Type: path_string  Path to a directory holding messages to submit to the middleware\nplugin.choria.use_srv  Type: boolean Additional Information: https://choria.io/docs/deployment/dns/ Default Value: true  If SRV record lookups should be attempted to find Puppet, PuppetDB, Brokers etc\nplugin.login.aaasvc.login.url  Type: comma_split Additional Information: https://choria-io.github.io/aaasvc/  List of URLs to attempt to login against when the remote signer is enabled\nplugin.nats.credentials  Type: string Environment Variable: MCOLLECTIVE_NATS_CREDENTIALS  The NATS 2.0 credentials to use, required for accessing NGS\nplugin.nats.pass  Type: string Environment Variable: MCOLLECTIVE_NATS_PASSWORD  The password to use when connecting to the NATS server\nplugin.nats.user  Type: string Environment Variable: MCOLLECTIVE_NATS_USERNAME  The user to connect to the NATS server as. When unset no username is used.\nplugin.scout.agent_disabled  Type: boolean  Disables the scout agent\nplugin.scout.goss.denied_local_resources  Type: comma_split  List of resource types to deny for Goss manifests loaded from local disk\nplugin.scout.goss.denied_remote_resources  Type: comma_split Default Value: command  List of resource types to deny when Goss manifests or variables were received over rpc\nplugin.scout.overrides  Type: path_string  Path to a file holding overrides for Scout checks\nplugin.scout.tags  Type: path_string  Path to a file holding tags for a Scout entity\nplugin.security.certmanager.alt_names  Type: comma_split  when using Cert Manager security provider, add these additional names to the CSR\nplugin.security.certmanager.api_version  Type: string Default Value: v1  the API version to call in cert manager\nplugin.security.certmanager.issuer  Type: string  When using Cert Manager security provider, the name of the issuer\nplugin.security.certmanager.namespace  Type: string Default Value: choria  When using Cert Manager security provider, the namespace the issuer is in\nplugin.security.certmanager.replace  Type: boolean Default Value: true  when using Cert Manager security provider, replace existing CSRs with new ones\nplugin.security.choria.ca  Type: path_string  When using choria security provider, the path to the optional Certificate Authority public certificate\nplugin.security.choria.certificate  Type: path_string  When using choria security provider, the path to the optional public certificate\nplugin.security.choria.key  Type: path_string  When using choria security provider, the path to the optional private key\nplugin.security.choria.seed_file  Type: path_string  The path to the seed file\nplugin.security.choria.sign_replies  Type: boolean Default Value: true  Disables signing replies which would significantly trim down the size of replies but would remove the ability to verify signatures or verify message origin\nplugin.security.choria.token_file  Type: path_string  The path to the JWT token file\nplugin.security.choria.trusted_signers  Type: comma_split  Ed25119 public keys of entities allowed to sign client and server JWT tokens in hex encoded format\nplugin.security.cipher_suites  Type: comma_split  List of allowed cipher suites\nplugin.security.client_anon_tls  Type: boolean Default Value: false  Use anonymous TLS to the Choria brokers from a client, also disables security provider verification - only when a remote signer is set\nplugin.security.ecc_curves  Type: comma_split  List of allowed ECC curves\nplugin.security.file.ca  Type: path_string  When using file security provider, the path to the Certificate Authority public certificate\nplugin.security.file.certificate  Type: path_string  When using file security provider, the path to the public certificate\nplugin.security.file.key  Type: path_string  When using file security provider, the path to the private key\nplugin.security.issuer.names  Type: comma_split  List of names of valid issuers this server will accept, set indvidiaul issuer data using plugin.security.issuer..public\nplugin.security.pkcs11.driver_file  Type: path_string Additional Information: https://choria.io/blog/post/2019/09/09/pkcs11/  When using the pkcs11 security provider, the path to the PCS11 driver file\nplugin.security.pkcs11.slot  Type: integer Additional Information: https://choria.io/blog/post/2019/09/09/pkcs11/  When using the pkcs11 security provider, the slot to use in the device\nplugin.security.provider  Type: string Validation: enum=puppet,file,pkcs11,certmanager,choria Default Value: puppet  The Security Provider to use\nplugin.security.server_anon_tls  Type: boolean Default Value: false  Use anonymous TLS to the Choria brokers from a server\nplugin.security.support_legacy_certificates  Type: boolean Default Value: false  Allow certificates without SANs to be used\nplugin.yaml  Type: path_string Default Value: /etc/puppetlabs/mcollective/generated-facts.yaml  Where to look for YAML or JSON based facts\nregisterinterval  Type: integer Default Value: 300  How often to publish registration data\nregistration  Type: comma_split  The plugins used when publishing Registration data, when this is unset or empty sending registration data is disabled\nregistration_collective  Type: string  The Sub Collective to publish registration data to\nregistration_splay  Type: boolean Default Value: true  When true delays initial registration publish by a random period up to registerinterval following registration publishes will be at registerinterval without further splay\nrpcaudit  Type: boolean Additional Information: https://choria.io/docs/configuration/aaa/ Default Value: false  When enabled uses rpcauditprovider to audit RPC requests processed by the server\nrpcauthorization  Type: boolean Additional Information: https://choria.io/docs/configuration/aaa/ Default Value: true  When enables authorization is performed on every RPC request based on rpcauthprovider\nrpcauthprovider  Type: title_string Additional Information: https://choria.io/docs/configuration/aaa/ Default Value: action_policy  The Authorization system to use\nrpclimitmethod  Type: string Validation: enum=first,random Default Value: first  When limiting nodes to a subset of discovered nodes this is the method to use, random is influenced by\nsoft_shutdown_timeout  Type: integer Default Value: 2  The amount of time to allow the server to exit, after this memory and thread dumps will be performed and a force exit will be done\nttl  Type: integer Default Value: 60  How long published messages are allowed to linger on the network, lower numbers have a higher reliance on clocks being in sync\n","description":"","tags":null,"title":"Config Reference","uri":"/configuration/index.html"},{"content":"These are documents describing some Architectural Designs\n   Document Description     ADR-001 Background and design of Protocol version 2 and the Choria Issuer based security layer    ","description":"","tags":null,"title":"Architecture","uri":"/adr/index.html"},{"content":"Choria binary, being a compiled binary with no external dependencies, needs to be recompiled when adding certain kinds of plugin, changing some default locations or adding your own plugins.\nThe project provides the tooling to perform these builds and has a compile-time configuration that can be adjusted to local needs.\nRequirements The host used to perform the compile need to have Docker on it and be able to fetch the registry.choria.io/choria/packager container. You can build a local version of the Packager using https://github.com/choria-io/packager.\nIn general you should only do this if you know what you are doing, have special needs, want custom agents etc.\nPlugins A number of plugins types are supported and we build many in at compile time ourselves.\nThe general process is that all the plugins in packager/plugins.yaml will be included in the build, if you want to add additional plugins you list them in packager/user_plugins.yaml.\nIf you wish to remove some default plugins you need to remove them from the packager/plugin.yaml.\nIn order to add your own RPC Agent you would list it in packager/user_plugins.yaml:\n--- acme: ghe.example.net/backplane/acme_agent During your CI run go get ghe.example.net/backplane/acme_agent then go generate and start the build:\nBUILD=foss VERSION=0.26.0acme rake build Your plugin will now be included in the final build, see choria buildinfo -D for al ist of all dependencies, which should include your plugin.\nCustom builds, paths and packages The choria-io/go-choria repository has packager/buildspec.yaml in it, this defines the binaries and packages to build, there are also some supporting files to call RPM, Deb etc.\nLets look at building a custom 64bit Linux binary with different paths and creating an Enterprise Linux 8 RPM.\nflags_map:  Version: github.com/choria-io/go-choria/build.Version  SHA: github.com/choria-io/go-choria/build.SHA  BuildTime: github.com/choria-io/go-choria/build.BuildDate  ProvisionJWTFile: github.com/choria-io/go-choria/build.ProvisionJWTFile  acme:  compile_targets:  defaults:  output: backplane-{{version}}-{{os}}-{{arch}}  flags:  ProvisionJWTFile: /etc/acme/backplane/provisioning.jwt  pre:  - rm additional_agent_*.go || true  - rm plugin_*.go || true  - go generate --run plugin   64bit_linux:  os: linux  arch: amd64   packages:  defaults:  name: backplane  display_name: Backplane  bindir: /opt/acme/bin  etcdir: /etc/acme/backplane  release: 1  manage_conf: 1  manage_server_preset: 0  contact: Backplane Engineering \u003cbackplane@eng.example.com\u003e  rpm_group: System Environment/Base  server_start_runlevels: \"-\"  server_start_order: 50  broker_start_runlevels: \"-\"  broker_start_order: 50   el8_64:  template: el/el8  dist: el8  target_arch: x86_64  binary: 64bit_linux We can now run:\nBUILD=acme VERSION=0.26.0acme rake build When you are done you will have:\n an rpm called backplane-0.26.0acme.el8.x86_64.rpm the binary will be /opt/acme/bin/backplane config files, log files, services all will be personalized around backplane it will have a custom path to the provisioning.jwt  A number of things are customizable see the section at the top of the buildspec.yaml and comments in the build file.\n","description":"","tags":null,"title":"Custom Packaging","uri":"/packaging/index.html"},{"content":"This section will from time-to-time contain guides on testing upcoming features and architectural changes.\n","description":"","tags":null,"title":"Tech Previews","uri":"/previews/index.html"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/index.html"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/index.html"}]