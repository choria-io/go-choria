<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.98.0"><meta name=generator content="Relearn 5.8.0"><meta name=description content><meta name=author content="Choria Project"><title>V2 Network Protocol :: Choria Server and Broker</title><link href=https://choria-io.github.io/go-choria/adr/001/index.xml rel=alternate type=application/rss+xml title="V2 Network Protocol :: Choria Server and Broker"><link href=https://choria-io.github.io/go-choria/css/fontawesome-all.min.css?1670864151 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=https://choria-io.github.io/go-choria/css/fontawesome-all.min.css?1670864151 rel=stylesheet></noscript><link href=https://choria-io.github.io/go-choria/css/featherlight.min.css?1670864151 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=https://choria-io.github.io/go-choria/css/featherlight.min.css?1670864151 rel=stylesheet></noscript><link href=https://choria-io.github.io/go-choria/css/auto-complete.css?1670864151 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=https://choria-io.github.io/go-choria/css/auto-complete.css?1670864151 rel=stylesheet></noscript><link href=https://choria-io.github.io/go-choria/css/perfect-scrollbar.min.css?1670864151 rel=stylesheet><link href=https://choria-io.github.io/go-choria/css/nucleus.css?1670864151 rel=stylesheet><link href=https://choria-io.github.io/go-choria/css/fonts.css?1670864151 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=https://choria-io.github.io/go-choria/css/fonts.css?1670864151 rel=stylesheet></noscript><link href=https://choria-io.github.io/go-choria/css/theme.css?1670864151 rel=stylesheet><link href=https://choria-io.github.io/go-choria/css/theme-choria-relearn.css?1670864151 rel=stylesheet id=variant-style><link href=https://choria-io.github.io/go-choria/css/ie.css?1670864151 rel=stylesheet><link href=https://choria-io.github.io/go-choria/css/variant.css?1670864151 rel=stylesheet><link href=https://choria-io.github.io/go-choria/css/print.css?1670864151 rel=stylesheet media=print><script src=https://choria-io.github.io/go-choria/js/url.js?1670864151></script>
<script src=https://choria-io.github.io/go-choria/js/variant.js?1670864151></script>
<script>window.index_json_url="https://choria-io.github.io/go-choria/index.json";var root_url="https://choria-io.github.io/go-choria/",baseUriFull,baseUri=root_url.replace(/\/$/,'');window.T_Copy_to_clipboard="Copy to clipboard",window.T_Copied_to_clipboard="Copied to clipboard!",window.T_Copy_link_to_clipboard="Copy link to clipboard",window.T_Link_copied_to_clipboard="Copied link to clipboard!",window.T_No_results_found="No results found for \u0022{0}\u0022",window.T_N_results_found="{1} results found for \u0022{0}\u0022",baseUriFull="https://choria-io.github.io/go-choria/",window.variants&&variants.init(["choria-relearn"])</script><script src=https://choria-io.github.io/go-choria/js/jquery.min.js?1670864151 defer></script></head><body class="mobile-support html disableInlineCopyToClipboard" data-url=https://choria-io.github.io/go-choria/adr/001/index.html><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable dir=ltr><div><div class=navigation><a class="nav nav-next" href=https://choria-io.github.io/go-choria/packaging/index.html title="Custom Packaging (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a></div><div class=navigation><a class="nav nav-prev" href=https://choria-io.github.io/go-choria/adr/index.html title="Architecture (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a></div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle title="Menu (CTRL+ALT+n)"><i class="fas fa-bars fa-fw"></i></a></span>
<span id=toc-menu title="Table of Contents (CTRL+ALT+t)"><i class="fas fa-list-alt fa-fw"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=https://choria-io.github.io/go-choria/index.html><span itemprop=name>Choria Server and Broker</span></a><meta itemprop=position content="1">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=https://choria-io.github.io/go-choria/adr/index.html><span itemprop=name>Architecture</span></a><meta itemprop=position content="2">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>V2 Network Protocol</span><meta itemprop=position content="3"></li></ol></div><div class="default-animation progress"><div class=toc-wrapper dir=ltr><nav id=TableOfContents><ul><li><a href=#background>Background</a><ul><li><a href=#current-state>Current State</a></li><li><a href=#problem-statement>Problem Statement</a></li><li><a href=#solution-overview>Solution Overview</a></li><li><a href=#issuing-jwt-tokens>Issuing JWT tokens</a></li><li><a href=#federation>Federation</a></li></ul></li><li><a href=#implementation>Implementation</a><ul><li><a href=#protocol>Protocol</a></li><li><a href=#chained-tokens-verification>Chained Tokens Verification</a></li><li><a href=#general-improvements>General Improvements</a></li></ul></li></ul></nav></div></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><div id=head-tags></div><article class=default><h1 id=v2-network-protocol>V2 Network Protocol</h1><h2 id=background>Background</h2><h3 id=current-state>Current State</h3><p>The Choria V1 protocol requires x509, there is no other option.</p><p>Experience with <code>mcollective</code> showed that companies had little appetite to understand or use esoteric security protocols, even those based on sound industry standard cryptographic methods. Further most companies already had mature x509 infrastructure either standalone or part of systems like Puppet which made for an easy adoption path.</p><p>Choria therefor is built on a protocol that requires x509 semantics and supports nothing else:</p><ul><li>Every message is signed by a x509 key</li><li>Every client-initiated message contains the x509 public key</li><li>Servers listen on TLS using x509 public and private keys</li><li>User identities are tied to the properties of the certificates</li><li>User permissions and roles are tied to the identity of the certificate, very limited support for fine-grained roles</li><li>All JWT files are signed by x509 keys</li><li>Generally only RSA is supported</li><li>mTLS is used to create a private network - requiring a purpose specific CA or intermediate CA in practise</li><li>A local cache of certificates is used like a kind of safety check to catch credentials being re-issued</li><li>Any NATS client connecting to Choria broker requires a cert/key/ca and do full mTLS</li></ul><p>Choria supports a mode combined with the AAA Server where a user does not need her own x509 certificate but holds a JWT instead obtained from an SSO service. In this scenario the AAA Server still holds a x509 cert (called a privileged certificate) and is allowed to sign and encode requests on behalf of others (holders of a JWT) by using its x509 key pair to sign on behalf of the user.</p><h3 id=problem-statement>Problem Statement</h3><p>In practise this works well for most users, but those with very large or complex networks can run into problems either with corporate Certificate Authority policies or corporate CA configuration making it very hard to achieve a secure network with the facilities available. General CA infrastructure is also just getting a bit old and better alternatives exist. JWTs are now used pervasively in modern IT and the user based are more likely to accept their use for our needs.</p><p>We would like to explore, and enable, other use cases outside of server management such as IoT, purpose built backplanes, Kubernetes side cars and more, integration into Certificate Authorities in those cases is really problematic.</p><ul><li>x509 signatures are big and slow</li><li>x509 certificates are also huge and these go with every request</li><li>x509 certificate management, especially across multiple client machines is very difficult</li><li>Dealing with short-lived (minutes) x509 certificates can be really hard</li><li>Not all CAs have sane enrollment, some requires private keys to be copied around making them useless</li><li>Newer technologies like ed25519 is attractive as they use small keys and signatures and can also do things like DH Key exchange</li><li>Using ed25519 opens the possibility of using ssh keys as signing keys, something many users have requested</li><li>Obtaining private CAs or intermediate CAs is often impossible forcing CA reuse and nullifying the usefulness of the mTLS security</li><li>Verification of certificates happen during caching rather than a separate check, more importantly the cache is used often as a means of retrieving privileged certs and more by id</li><li>The local cert cache is deeply embedded in the v1 protocol, but it&rsquo;s proven to be useless and most people disable its enforcing features - it cannot be disabled entirely</li><li>As Choria have evolved we need a much more granular role based permissions on each connection - can they use streams, can they admin streams, can they make rpc requests etc</li><li>More and more servers need to be able to make request either when publishing signed registration payloads or when interacting with Choria Services from within autonomous agents. With v1 protocol this was not possible.</li></ul><h3 id=solution-overview>Solution Overview</h3><p>We will support an additional protocol, while maintaining v1 protocol, that will be based on JWTs signed using ed25519 that embed their public component in the signed JWT.</p><p>We have already done the work to design and incorporate the JWTs for clients and servers at the transport level but now need to move that work into the Choria protocol so clients can communicate with Choria without x509 certificates.</p><h4 id=transport-security>Transport Security</h4><p>Transport security is primarily about how the packets between Choria Broker and Choria Client/Server are secured but touches a bit on how users with access to the NATS Server are limited to just their traffic.</p><h5 id=mtls-optional-chain-of-trust-for-transport-security>mTLS optional Chain of Trust for transport security</h5><p>In a mTLS secured network trust is established by way of the CA signing all certificates and all parties verifying this fact. Both sides of the TLS connection will verify the other side to ensure its certificate is signed by a cached local CA chain.</p><p>This way there can be no untrusted middlemen or session hijacking in the network path.</p><p>In practise, in enterprise networks, there are many challenges:</p><ul><li>it&rsquo;s often highly desirable to be able to hijack connections, for example to audit that PII doesn&rsquo;t leave the legal jurisdiction it belongs in, many companies wish to disable the full mTLS while still maintaining strong identification of entities.</li><li>it&rsquo;s also desirable to deploy Choria Brokers using websocket protocol and offload the TLS work onto a load balancer - this would be quite complex with the current model.</li><li>most enterprise have policies making CA rotation necessary and quite frequent, this makes mTLS completely unworkable at scale.</li><li>dropping mTLS, or not being able to do mTLS, would impact the strength of identity since we combine the transport and identity in one cert</li><li>certificate enrolment is done poorly, there are few protocols like ACME in use in Enterprises, often they would design their own enrollment, and mostly it involves moving keys between machines and are very slow</li></ul><p>So we will support verified or unverified TLS to the brokers, but clients and servers all must present a signed JWT when not in mTLS mode. This will split the identity from transport security and give people the choice to pick one without compromising the other.</p><p>Servers and clients will have:</p><ul><li>An ed25519 seed file example <code>server.seed</code> kept private and never transmitted over the network</li><li>A JWT file that holds:<ul><li>the public key of the ed25519 seed</li><li>an identity</li><li>a private network ID derived from the identity or seed</li><li>Standard items like expiry times etc</li><li>Additional permissions to control access to broker subjects</li></ul></li><li>The JWT will be signed by a trusted ed25519 key</li></ul><p>The broker will only allow connections that holds a valid, signed JWT where the signature is made using a trusted ed25519 key.</p><h5 id=organisation-and-chained-issuers>Organisation and Chained Issuers</h5><p>Conceptually Choria Broker can separate connections into something called &ldquo;accounts&rdquo; in NATS terms, for Choria we call this an Organization. Today we support just one Organization - <code>choria</code> - but we will look to support more in future.</p><p>We will add a concept called an Organization Issuer that is a ed25519 key that must, on a basic level, sign all tokens. To facilitate separation of concerns in our centralized AAA mode the Issuer can delegate JWT issuing in a chain to downstream issuers. The tokens will validate as being signed by the issuer essentially.</p><p>We support storing the Organization Issuer offline in something like Vault and at the &ldquo;AAA Login Server&rdquo; level that issuing key can also be stored in a Vault like system.</p><p><a href=https://choria-io.github.io/go-choria/org-issuers.png data-featherlight=image><img src=https://choria-io.github.io/go-choria/org-issuers.png alt="Chain Issuers" style=height:auto;width:auto loading=lazy></a></p><p>Thus, we achieve the following chain of trust:</p><ul><li>We know the JWT was issued by a trusted issuer</li><li>We verify the connecting server or client has the ed25519 seed that match the JWT because the broker force a <a href=https://en.wikipedia.org/wiki/Cryptographic_nonce>NONCE</a> to be signed using the seed, the seed never traverse the network since the public part is embedded in the signed JWT</li><li>The JWT tokens are therefor not bearer tokens and if they are stolen in-flight (remember no mTLS), one cannot connect with them or make any requests using them</li><li>We have an identity that isn&rsquo;t tied to the common name of a cert and so is more fluid and adaptable</li><li>The broker should support <a href=https://github.com/choria-io/go-choria/issues/1837>denying all clients without JWTs</a></li></ul><p>In this way we can pick full mTLS when needed or JWT+ed25519 mode when needed and even mix and match the modes.</p><h4 id=reply-security>Reply Security</h4><p>Reply security is a quite difficult problem to solve since every reply would need to be individually encrypted and decrypted - unlike transport security - this is very CPU intensive, so we have never really done it at scale.</p><p>Still, its highly desirable to hide replies destined for a specific user from other users, even those with access to the broker using their own JWT tokens.</p><p>Using the callerID as key we calculate a private inbox using the hex encoded <code>md5(callerID)</code>, we use this to construct reply subjects for all uses, even access to other subjects like the Streams API.</p><p>The broker will set up permissions ensuring that only the callerID can access replies. This way as long as there are unique callerIDs the replies from all systems are private.</p><p>We still do not encrypt the traffic in-transit (see point about PII and desired man-in-the-middle in Enterprises), but the replies are private to the user.</p><pre tabindex=0><code>% sudo choria jwt client.jwt
...
   Private Network ID: 7419405695a186147a0de38f7e31a509...
...

% choria req choria_util info --debug
DEBU[0000] Publishing message with reply to choria.reply.7419405695a186147a0de38f7e31a509.4e27ca6493cb4576bb78e90ea35df38c  component=client
</code></pre><p>Here we can see the reply is set to match <code>&lt;collective>.reply.&lt;private network id>.&lt;request id></code>, the broker ensures the holder of this JWT cannot subscribe to other users replies.</p><p>To facilitate debugging users with the <code>OrgAdmin</code> permission, default not granted, on their tokens can view all replies.</p><h4 id=submission-and-registration-data-security>Submission and Registration Data Security</h4><p>As each server will have a ed25519 seed and a JWT embedding the public key we will support, optionally, signing Choria Submission and Registration messages. Signatures and Tokens will be included in headers.</p><p>This way should a system need to be created where the node will ask in an async manner for operations to be done against it, think host-detected issues triggering auto remediation, these messages originating from Submission will be signed.</p><p>Recipients of these messages can be certain that the message originated from a place that had access to the nodes private key.</p><p>See <a href=https://github.com/choria-io/go-choria/issues/1873>#1873</a></p><h4 id=identity>Identity</h4><p>Identity primarily concerns Choria Requests, this is who is the one making the request for the use by AAA.</p><p>Traditionally this is extracted from the x509 certificate common name and have some dumb rules like <code>x.choria</code> or <code>x.privileged.choria</code> since x509 certificates don&rsquo;t really have a strong concept of boolean permissions.</p><p>This is awful and arbitrary, in the new model callers should be whatever they like and a flag on the JWT would identify it as privileged or not (<a href=https://github.com/choria-io/go-choria/issues/1836>#1836</a>).</p><h4 id=caller-identity>Caller Identity</h4><p>Identity would always be extracted from the JWT of the final client. In the case of the AAA Service we would need to have the ability to include the client JWT as well as the signer JWT and the signature:</p><ul><li>When the signer JWT isn&rsquo;t set we ensure the client signed it.</li><li>When the signer JWT is set we ensure the JWT has the right permission to sign others requests (<a href=https://github.com/choria-io/go-choria/issues/1836>#1836</a>)</li><li>The identity of the client JWT is used for the request</li><li>We should be able to issue JWTs that can only be used in conjunction with an AAA server who signs their requests (<a href=https://github.com/choria-io/go-choria/issues/1840>#1840</a>)</li></ul><p>This would be the identity used in things like RBAC, Audit logs and more.</p><p>The broker might set the NATS user to the identity to assist with debugging.</p><h4 id=request-signatures>Request Signatures</h4><p>Today requests are signed by the x509/RSA key, we&rsquo;d just sign it with the ed25519 seed instead. We would not support any form of server side cache.</p><p>Client JWTs will gain permissions that state they have fleet management access and, optionally, that fleet management access requires signatures.</p><h3 id=issuing-jwt-tokens>Issuing JWT tokens</h3><p>Traditionally you would use whatever your CA does for enrolling certificates and <code>choria enroll</code> might help you out if you&rsquo;re lucky to have a system that supports that.</p><p>For others, it would be up to the user to deliver the key, cert and ca to the right locations.</p><p>Having Server enroll separate from Client enroll is good, since its conceivable that those will be done in very different places and with different auth mechanisms.</p><h4 id=servers>Servers</h4><p>Servers would get their JWT token from the Choria Provisioner, this is supported today and that supports setting permissions and more. The Provisioner would hold a JWT that is a Chain Issuer allowing it to sign JWTs for servers.</p><h4 id=clients>Clients</h4><p>The current AAA Server should be extended to allow client enrollment, essentially this is already supported but there is no allowance for the client seed and new behaviors. The signing request should be extended with a signature made using the seed and the service should verify it - essentially same as the NONCE in the broker.</p><p>The AAA Service would support marking a user as standalone - he can make his own requests without AAA and has his own seed - or as requiring AAA service (<a href=https://github.com/choria-io/go-choria/issues/1840>#1840</a>). He might have his own seed for signing the broker NONCE but cannot make RPC requests that were not signed by AAA service.</p><p>The AAA Login handler would hold a JWT that is a Chain Issuer allow it to sign JWTs for the clients and set policies and permissions.</p><p>The <code>choria jwt</code> command must also be able to issue client credentials.</p><p>Non Choria clients - like lets say a random node nats client - would need to get their hands on a JWT and seed as well, and they will have to connect with that. So there will have to be a way to enroll them, probably <code>choria jwt</code> or <code>choria login</code> with their user marked as being long term valid.</p><p>A final class of client is one that needs a short-lived permission to make a very specific request. Imagine some external orchestrator wants to invoke <code>choria req</code> or <code>choria kv</code> for a particular use. Ideally this external Orchestrator would be able to issue a JWT that would allow this to happen on any unix user. In this scenario <code>choria login</code> should be able to take a bearer token and present that to AAA service during <code>choria login</code>. The bearer token would be signed by the orchestrator and trusted by the AAA, the bearer token would be very short-lived and essentially single use. It will be used to facilitate login, Choria JWT creation and more so that the unix user would still have an ed25519 seed, but the Choria Client JWT would be custom and short-lived and restricted to purpose.</p><h3 id=federation>Federation</h3><p>The federation system allows for moving requests and replies between uncoupled networks - essentially it&rsquo;s a protocol converter and gateway.</p><p>We would not in the past create federation that would cross CA boundaries as resigning all the requests and replies was impossible. With the new system the Federation Broker should be able to have a token with Authentication Delegation set and just re-sign the request en-route. This will allow it to do translation between networks and ID schemes.</p><h2 id=implementation>Implementation</h2><p>The protocol in Choria largely defines the bytes that traverse the network and couples quite tightly with the security providers for encoding, signing etc.</p><p>In the work to support v2 protocol we are also revisiting the design of the security plugins to be more generic and support non x509 key data.</p><h3 id=protocol>Protocol</h3><p>Layered protocols are used widely and bring with them a lot of flexibility in replacing some layer with another, for example: Ethernet -> IP -> TCP -> HTTP -> REST.</p><p>Choria has a similar design:</p><pre tabindex=0><code>( Transport
  ( Secure Request or Reply
    ( Request or Reply
      ( Any bytes, often: RPC Request or Reply )
    )
  )
)
</code></pre><p>The efforts with v2 protocol is to replace Transport, Secure and Request/Reply with a new design, still based on JSON, but with better choices internally.</p><h4 id=request>Request</h4><p>A request holds the actual bytes being moved around and various claims about who is making the request.</p><table><thead><tr><th>Field</th><th>v1</th><th>Description</th></tr></thead><tbody><tr><td><code>protocol</code></td><td><code>protocol</code></td><td>The protocol version for this request <code>io.choria.protocol.v2.request</code></td></tr><tr><td><code>message</code></td><td><code>payload</code></td><td>The arbitrary data contained in the request - like a RPC request - as base64 encoded bytes</td></tr><tr><td><code>id</code></td><td><code>requestid</code></td><td>The unique ID for the request, logged in AAA etc</td></tr><tr><td><code>sender</code></td><td><code>senderid</code></td><td>Typically the host that the request was initiated from</td></tr><tr><td><code>caller</code></td><td><code>callerid</code></td><td>Who made the request in the form of <code>kind=name</code></td></tr><tr><td><code>collective</code></td><td><code>collective</code></td><td>Collective this request is targeted at</td></tr><tr><td><code>agent</code></td><td><code>agent</code></td><td>The agent this request is targeted at</td></tr><tr><td><code>ttl</code></td><td><code>ttl</code></td><td>How long this request is valid for</td></tr><tr><td><code>time</code></td><td><code>time</code></td><td>The unix nano time the request was created (unix time in v1)</td></tr><tr><td><code>filter</code></td><td><code>filter</code></td><td>The request filter</td></tr></tbody></table><h4 id=secure-request>Secure Request</h4><p>A secure request wraps a <code>Request</code>, signs it and prevents any tampering with its content.</p><p>The signature - having been made with a private key - also conveys identity and confirms the claimed identity in the Request matches what cryptographic keys are held.</p><p>The main purpose of the Secure Request is to verify what can be verified about the Request and make immutable the rest. For example, we can&rsquo;t exactly verify the request time and TTL, but we can prevent it from being changed by an attacker by signing it. The caller in the <code>Request</code> is not verified in the <code>Request</code> since it&rsquo;s just an arbitrary string, however the Secure Request being signed using something unique to the caller, private key, confirms the information in the request.</p><p>So the end result is immutable, or at least tamper evident, metadata about a request and likewise the request payload or message.</p><table><thead><tr><th>Field</th><th>v1</th><th>Description</th></tr></thead><tbody><tr><td><code>protocol</code></td><td><code>protocol</code></td><td>The protocol version for this secure request <code>io.choria.protocol.v2.secure_request</code></td></tr><tr><td><code>request</code></td><td><code>message</code></td><td>The request held in the Secure Request as base64 bytes</td></tr><tr><td><code>signature</code></td><td><code>signature</code></td><td>A signature made of the request using the ed25519 seed of the caller</td></tr><tr><td><code>caller</code></td><td><code>pubcert</code></td><td>The JWT of the caller</td></tr><tr><td><code>signer</code></td><td>n/a</td><td>The JWT of the delegated signer, present when the AAA server is used</td></tr></tbody></table><h4 id=reply>Reply</h4><p>A reply is created in response from a request and holds the request id in its payload</p><table><thead><tr><th>Field</th><th>v1</th><th>Description</th></tr></thead><tbody><tr><td><code>protocol</code></td><td><code>protocol</code></td><td>The protocol version for this reply <code>io.choria.protocol.v2.reply</code></td></tr><tr><td><code>message</code></td><td><code>payload</code></td><td>The arbitrary data contained in the reply - like a RPC reply</td></tr><tr><td><code>request</code></td><td><code>requestid</code></td><td>The ID of the request this reply relates to</td></tr><tr><td><code>sender</code></td><td><code>senderid</code></td><td>The host sending the reply</td></tr><tr><td><code>agent</code></td><td><code>agent</code></td><td>The agent the reply originates from</td></tr><tr><td><code>time</code></td><td><code>time</code></td><td>The unix nano time the request was created (unix time in v1)</td></tr></tbody></table><h4 id=secure-reply>Secure Reply</h4><p>A secure reply wraps a <code>Reply</code>, signs it and prevents any tampering with its content. The hash is a fast way to test validity of the reply.</p><p>Like the Secure Request the Secure Reply wraps the Reply in a way that makes it tamper evident via signatures and hashes.</p><p>The v2 protocol includes a signature and sender JWT however in practise this is mostly not going to be used as too costly on the receiver, however might be used for registration payload verification.</p><p>Signatures add quite a bit to the payload here, as the JWT has to be sent with, so it can be disabled using <code>plugin.security.choria.sign_replies</code> in the new security provider.</p><table><thead><tr><th>Field</th><th>v1</th><th>Description</th></tr></thead><tbody><tr><td><code>protocol</code></td><td><code>protocol</code></td><td>The protocol version for this secure reply <code>io.choria.protocol.v2.secure_reply</code></td></tr><tr><td><code>reply</code></td><td><code>message</code></td><td>The reply held in the Secure Request as base64 bytes</td></tr><tr><td><code>hash</code></td><td><code>hash</code></td><td>A sha256 of the reply</td></tr><tr><td><code>signature</code></td><td>n/a</td><td>A signature made using the ed25519 seed of the sender</td></tr><tr><td><code>sender</code></td><td>n/a</td><td>The JWT of the sending host</td></tr></tbody></table><h4 id=transport>Transport</h4><p>The transport packet is the last layer that gets sent over NATS, it holds no message specific data.</p><table><thead><tr><th>Field</th><th>v1</th><th>Description</th></tr></thead><tbody><tr><td><code>protocol</code></td><td><code>protocol</code></td><td>The protocol version for this transport <code>io.choria.protocol.v2.transport</code></td></tr><tr><td><code>data</code></td><td><code>data</code></td><td>The payload to be transport, a Secure Request or Secure Reply base64 encoded</td></tr><tr><td><code>headers</code></td><td><code>headers</code></td><td>Optional headers</td></tr></tbody></table><p>Headers:</p><table><thead><tr><th>Field</th><th>v1</th><th>Description</th></tr></thead><tbody><tr><td><code>reply</code></td><td><code>reply-to</code></td><td>A transport specific response channel for this message, used in requests</td></tr><tr><td><code>sender</code></td><td><code>mc_sender</code></td><td>The host that sent this message</td></tr><tr><td><code>trace</code></td><td><code>seen-by</code></td><td>A trace of host/broker pairs that the message traversed</td></tr><tr><td><code>federation</code></td><td><code>federation</code></td><td>Headers to assist federation</td></tr></tbody></table><p>Federation:</p><table><thead><tr><th>Field</th><th>v1</th><th>Description</th></tr></thead><tbody><tr><td><code>request</code></td><td><code>req</code></td><td>The request ID a federated message belongs to</td></tr><tr><td><code>reply</code></td><td><code>reply-to</code></td><td>The original <code>reply</code> before federation</td></tr><tr><td><code>targets</code></td><td><code>targets</code></td><td>The identities who the federated message is for</td></tr></tbody></table><h3 id=chained-tokens-verification>Chained Tokens Verification</h3><p>We created a Chained Token system in <a href=https://github.com/choria-io/go-choria/issues/1900>#1900</a> that allows a Organization Issuer to delegate Client and Server creation to Chained Issuers.</p><p>From a usage perspective you can say <code>tokens.ParseClientIDToken(t, pubk)</code> where the public key is the public part of the Organisation Issuer, even when the token <code>t</code> is signed by a Chain Issuer. The intention is to make the configuration of a chain much easier, you only have to configure the issuer for an Organization.</p><p>Additionally the expiry of the Chain Issuer is encoded in the token, if the issuer expires first the issued token is also considered expired.</p><p>The way this is achieved is with a series of claims and signatures as described here:</p><p>The Organization Issuer for an Organization is simply an <code>ed25519</code> key for the moment. If that Org Issuer is just signing some client, server or provisioner nothing special is done, it&rsquo;s just signing a JWT like normal.</p><p>However if the Org Issuer wants to create a token that can sign other tokens additional information is added a Clent token, it&rsquo;s called the <strong>Chain Issuer</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;iss&#34;</span>: <span style=color:#e6db74>&#34;I-514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;jti&#34;</span>: <span style=color:#e6db74>&#34;ffdbaaedc9c141f6a99c14b5b66f62ac&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;ou&#34;</span>: <span style=color:#e6db74>&#34;choria&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;public_key&#34;</span>: <span style=color:#e6db74>&#34;bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;purpose&#34;</span>: <span style=color:#e6db74>&#34;choria_client_id&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;tcs&#34;</span>: <span style=color:#e6db74>&#34;3f815723734c78ceaba5fb506347565f85fe2a0334c038ba2370c7f53f35e6c7c75ed3e95b531b6049426638201c39639dbf9b711fba5d866e7e3e30be02b401&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>jti</code> is a unique ID for this token</li><li><code>iss</code> field indicates it is signed by a Issuer with public key <code>514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec</code>.</li><li><code>public_key</code> is the public part of the ed25519 seed for the Chain Issuer <code>aaa_chain_delegator</code></li><li><code>tcs</code> is a signature made of <code>[chain issuer id].[chain issuer public key]</code> using the Org Issuer private key, in other words <code>sig("ffdbaaedc9c141f6a99c14b5b66f62ac.bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687", orgIssuerPrik)</code></li><li>The Chain Issuer JWT is signed by the Organization Issuer</li></ul><p>This way we can verify that the Chain Issuer comes from the Issuer both by verifying the signature but also we have a piece of information that cannot be changed down the line (the <code>tcs</code>, signed by the Org Issuer key) which we will see again later.</p><p>In code this information, signatures etc can all be added using <code>chainIssuer.AddOrgIssuerData(issuerPrik)</code>, with this added the token <code>chainIssuer</code> can issue other tokens. For a possible future integration with systems like Vault we would call out to the Vault API to sign the <code>tcs</code> plain text and then sign the token, hence the Organization Issuer private key never needs to leave Vault.</p><p>Now when the Chain Issuer wants to issue a new Client or Server token additional information is again added:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;callerid&#34;</span>: <span style=color:#e6db74>&#34;up=rip&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;iss&#34;</span>: <span style=color:#e6db74>&#34;C-ffdbaaedc9c141f6a99c14b5b66f62ac.bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;issexp&#34;</span>: <span style=color:#ae81ff>1700153647</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;jti&#34;</span>: <span style=color:#e6db74>&#34;b2375f965abe4bfbaf131b585cf5e1a1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;ou&#34;</span>: <span style=color:#e6db74>&#34;choria&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;public_key&#34;</span>: <span style=color:#e6db74>&#34;676d07de6721ee396754d4e4d5fa4ee2b59a6f3b8208e760ca614bc66000e740&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;purpose&#34;</span>: <span style=color:#e6db74>&#34;choria_client_id&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;tcs&#34;</span>: <span style=color:#e6db74>&#34;3f815723734c78ceaba5fb506347565f85fe2a0334c038ba2370c7f53f35e6c7c75ed3e95b531b6049426638201c39639dbf9b711fba5d866e7e3e30be02b401.a9da5f3946c1b472f1c886912bfe5559f261e4663016846e231095bd2e16a8a253657196a5c17231fb095bc3a2d1e89e1edaddcec35dd050303e5d9cda968a04&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>jti</code> is a unique id for this token</li><li><code>iss</code> indicates a Chain Issuer with token ID (<code>jti</code>) <code>ffdbaaedc9c141f6a99c14b5b66f62ac</code> issued this token and his public key is <code>bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687</code> (the one from the previous example)</li><li><code>issexp</code> indicates when the Chain Issuer expires</li><li><code>tcs</code> is made up of first creating <code>sigdata</code> <code>[client token jti].[chain issuer tcs]</code> and then combining that <code>[chain issuer tcs].[sig(sigdata, chainIssuerPrik)]</code></li></ul><p>This way we can, given the signed Client token and the Org Issuer Public key, validate by going backwards over these claims:</p><ol><li>Extract the Chain Issuer <code>tcs</code>, <code>public key</code> and <code>id</code> from <code>iss</code> and <code>tcs</code></li><li>Verify the Organization Issuer signed the <code>tcs</code> of the Chain Issuer in this token, which also verifies the public key in the issuer</li><li>Verify the <code>tcs</code> signature part of the Client using public key of the Chain Issuer</li><li>Verify the expiry of the Chain Issuer</li></ol><h3 id=general-improvements>General Improvements</h3><p>The security plugins handle signing, encoding, extracting of IDs and validating signatures. The current security plugins are all implemented around x509.</p><p>We will make some general improvements, rename some functions and add a few bits to the interface, detail to be discovered during implementation.</p><ul><li>Move the API to <code>[]byte</code> based API <a href=https://github.com/choria-io/go-choria/pull/1844>#1844</a></li><li>Remove some string orientated security apis <a href=https://github.com/choria-io/go-choria/pull/1843></a></li><li>Make the JWT authoritative for the secure channel name so we can stop using md5</li><li>Develop a tool that can decode and dump/view network packets <a href=https://github.com/choria-io/go-choria/pull/1848>#1484</a></li><li>The entire concept of the cache to be removed <a href=https://github.com/choria-io/go-choria/pull/1842>#1842</a></li><li>Default collective when v2 is used will be <code>choria</code> <a href=https://github.com/choria-io/go-choria/pull/1885>#1885</a></li><li>Submission can sign messages <a href=https://github.com/choria-io/go-choria/issues/1873>#1873</a></li><li>The protocol code should be instances not a singleton so each can have unique contextes and logging</li><li>Stronger AAA interactions by signing NONCE like data in login and sign requests</li><li>Potentially entirely remove the concept of Trusted Signers that was a mid term stop gap till this work is complete, only used by 1 users as far as we are aware</li></ul><footer class=footline></footer></article></div></main></div><aside id=sidebar class=default-animation dir=ltr><div id=header-wrapper class=default-animation><div id=header class=default-animation><img src=https://choria-io.github.io/go-choria/logo.png></div><div class="searchbox default-animation"><i class="fas fa-search" title="Search (CTRL+ALT+f)"></i>
<label class=a11y-only for=search-by>Search</label>
<input data-search-input id=search-by name=search-by class=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script>var contentLangs=["en"]</script><script src=https://choria-io.github.io/go-choria/js/auto-complete.js?1670864151 defer></script>
<script src=https://choria-io.github.io/go-choria/js/lunr.min.js?1670864151 defer></script>
<script src=https://choria-io.github.io/go-choria/js/lunr.stemmer.support.min.js?1670864151 defer></script>
<script src=https://choria-io.github.io/go-choria/js/lunr.multi.min.js?1670864151 defer></script>
<script src=https://choria-io.github.io/go-choria/js/lunr.en.min.js?1670864151 defer></script>
<script src=https://choria-io.github.io/go-choria/js/search.js?1670864151 defer></script></div><div id=content-wrapper class=highlightable><ul class=topics><li data-nav-id=/broker/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/broker/index.html><b>1. </b>Choria Broker</a><ul id=subsections-dfbddd42a1cd83043778d347f4552a1e><li data-nav-id=/broker/monitoring/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/broker/monitoring/index.html><b>1. </b>Monitoring</a></li></ul></li><li data-nav-id=/server/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/server/index.html><b>2. </b>Choria Server</a><ul id=subsections-4c6fcb62c73c779f9a17e7db39822c85><li data-nav-id=/server/monitoring/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/server/monitoring/index.html><b>1. </b>Monitoring</a></li></ul></li><li data-nav-id=/installation/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/installation/index.html><b>3. </b>Installation</a></li><li data-nav-id=/configuration/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/configuration/index.html><b>4. </b>Config Reference</a></li><li data-nav-id=/adr/index.html class="dd-item parent"><a href=https://choria-io.github.io/go-choria/adr/index.html><b>5. </b>Architecture</a><ul id=subsections-55dd4997ce122937146cb3b0f5ba2d2d><li data-nav-id=/adr/001/index.html class="dd-item active"><a href=https://choria-io.github.io/go-choria/adr/001/index.html><b>1. </b>V2 Network Protocol</a></li></ul></li><li data-nav-id=/packaging/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/packaging/index.html><b>6. </b>Custom Packaging</a></li><li data-nav-id=/previews/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/previews/index.html><b>7. </b>Tech Previews</a><ul id=subsections-c322ebf88a778ba74af3e7821cdcadaa><li data-nav-id=/previews/protov2/index.html class=dd-item><a href=https://choria-io.github.io/go-choria/previews/protov2/index.html><b>1. </b>V2 Protocol & Security</a></li></ul></li></ul><div id=shortcuts><div class=nav-title>More</div><ul><li><a class=padding href=https://github.com/choria-io/go-choria><i class="fab fa-fw fa-github"></i> GitHub</a></li><li><a class=padding href=https://github.com/choria-io/general/discussions><i class="far fa-comments"></i> Discussions</a></li><li><a class=padding href=https://github.com/choria-io/go-choria/issues><i class="far fa-life-ring"></i> Issues</a></li><li><a class=padding href=https://slack.puppet.com/><i class="fab fa-slack"></i> #choria</a></li></ul></div><div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showFooter"></div><hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showFooter"><div id=prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks"><ul><li id=select-language-container class=footerLangSwitch><div class="padding select-container"><i class="fas fa-language fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-language>Language</label>
<select id=select-language onchange="location=baseUri+this.value"></select></div><div class=select-clear></div></div></li><li id=select-variant-container class=footerVariantSwitch><div class="padding select-container"><i class="fas fa-paint-brush fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-variant>Theme</label>
<select id=select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=choria-relearn value=choria-relearn selected>Choria Relearn</option></select></div><div class=select-clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class=footerVisitedLinks><button class=padding onclick=clearHistory()><i class="fas fa-history fa-fw"></i> Clear History</button></li></ul></div><div id=footer class="footerFooter showFooter"><style>#footer{font-size:13px;height:100px;margin-left:auto;margin-right:auto;padding:2rem 1rem;text-align:center;min-width:230px;max-width:300px}#footer p{margin:0}</style><p>Hosted at <a href=https://github.com/choria-io>GitHub</a> by <a href=https://www.devco.net/>R.I. Pienaar</a></p></div></div></aside><script src=https://choria-io.github.io/go-choria/js/clipboard.min.js?1670864151 defer></script>
<script src=https://choria-io.github.io/go-choria/js/perfect-scrollbar.min.js?1670864151 defer></script>
<script src=https://choria-io.github.io/go-choria/js/featherlight.min.js?1670864151 defer></script>
<script src=https://choria-io.github.io/go-choria/js/theme.js?1670864151 defer></script></body></html>