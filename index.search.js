var relearn_search_index=[{breadcrumb:"",content:`Choria Broker is a set of features that, in a fully decentralized setup, is the only central component Choria needs. It is highly available, clustered and very high performance. The messaging layer is based on NATS with a number of Choria specific additions.
A single Choria Broker can manage 50,000 devices on a low budget compute instance - though a cluster of at least 3 brokers is recommended for availability reasons.
Features Choria Brokers is the core message passing middleware, this is a managed NATS Core instance Choria Streams is the data streaming solution used by various Choria components, this is a managed NATS JetStream instance Choria Federation Broker connects entirely isolated Choria networks into a federated single network Choria Data Adapters to move data from Choria Broker to other technologies A Choria specific authentication layer `,description:"",tags:null,title:"Choria Broker",uri:"/broker/index.html"},{breadcrumb:"Choria Broker",content:`Choria Broker is just one process running in your server, the command systemctl status choria-broker will show a basic overview of the process running, you should have basic monitoring for the process in place.
Prometheus Metrics By default, the broker does not expose any monitoring metrics, if you set the plugin.choria.stats_port configuration to a port number it will listen on that port. You can listen on non localhost by setting plugin.choria.stats_address.
It will then serve a number of URLs, some from Choria and some from the embedded NATS Server - see NATS Monitoring for detail about those.
Path Description /choria/ Build information, run-time resource use /choria/metrics Prometheus format metrics System Account Monitoring NATS and Choria Streams require a System account enabled:
plugin.choria.network.system.user = system plugin.choria.network.system.password = s3cretThis should be set in the Broker configuration and any client who wish to access the broker.
We have a basic Dashboard you can use to view these.
Included Checks Tip All the choria broker server commands are from the embedded NATS CLI and so can be an awkward fit within our CLI hierarchy
We include a number of checks in the binary that can be used to monitor various aspects of the service.
Command Description choria broker server check connection Performs a basic network connection and round-trip test of the NATS service choria broker server check stream Checks the health of individual Choria Streams Streams choria broker server check meta Checks the health of the overall Choria Streams System choria broker server check jetstream Checks Choria Streams usage limits choria broker server check server Checks the health of the embedded NATS Server choria broker server check kv Checks the health of Choria Key-Value buckets All of these Checks require the System Account to be enabled in your broker and the client configuration to have the same settings. A custom Choria Client configuration can be set using --choria-config on these commands.
By default, these commands act like Nagios checks:
% choria broker server check js OK JetStream | memory=0B memory_pct=0%;75;90 storage=1942997776B storage_pct=0%;75;90 streams=13 streams_pct=0% consumers=21 consumers_pct=0% % echo $? 0They can though also output json, prometheus and text formats:
% choria broker server check js --format text JetStream: OK Check Metrics ╭───────────────┬───────────────┬──────┬────────────────────┬───────────────────╮ │ Metric │ Value │ Unit │ Critical Threshold │ Warning Threshold │ ├───────────────┼───────────────┼──────┼────────────────────┼───────────────────┤ │ memory │ 0.00 │ B │ 0.00 │ 0.00 │ │ memory_pct │ 0.00 │ % │ 90.00 │ 75.00 │ │ storage │ 1942955289.00 │ B │ 0.00 │ 0.00 │ │ storage_pct │ 0.00 │ % │ 90.00 │ 75.00 │ │ streams │ 13.00 │ │ 0.00 │ 0.00 │ │ streams_pct │ 0.00 │ % │ -1.00 │ -1.00 │ │ consumers │ 21.00 │ │ 0.00 │ 0.00 │ │ consumers_pct │ 0.00 │ % │ -1.00 │ -1.00 │ ╰───────────────┴───────────────┴──────┴────────────────────┴───────────────────╯Reports Several run time reports are included that can show connection states and more, all of these require the System Account.
List Brokers in the cluster This shows all the connected NATS Servers / Choria Brokers in your cluster and some basic information about them
$ choria broker server listBroker Connections You can view and search active connections to your brokers, here we limit it to the top-5 by subject, see --help for other options
% choria broker server report connections --top 5Add the --account=provisioning option to see connections waiting to be provisioned if enabled.
Streams Report One can get a overview of Choria Streams backends:
% choria broker server report jetstreamDetails Broker Data A wealth of data is available in the Brokers about every connection and every subscription and more, run choria broker server req --help to see a full list.
Golang Profiling As an advanced option, that should not be enabled by default, one can enable the Golang PProf port to facilitate deep debugging of memory allocations and more. How to use this is out of scope of this document and really only useful for developers.
plugin.choria.network.pprof_port = 9090`,description:"",tags:null,title:"Monitoring",uri:"/broker/monitoring/index.html"},{breadcrumb:"Choria Server",content:`Choria Server is designed to not open any listening ports unless its Apple HomeKit integration is enabled.
Without any opening ports monitoring it is via a state file that it writes regularly when enabled:
plugin.choria.status_file_path = /var/log/choria-status.json plugin.choria.status_update_interval = 30The above configuration will cause the status file to update every 30 seconds. This needs to be enabled for any deep introspection.
Nagios Check A nagios protocol test is included in the command choria tool status, this can check various aspects of the server operation.
$ choria tool status --status-file /var/log/choria-status.json \\ --disconnected \\ # alerts when the server is not connected to a broker --message-since 1h \\ # must have received RPC requests within the last 1 hour --max-age 1m \\ # Status file may not be older than 1 minute --token-age 24h \\ # Alert 1 day before the token expires --certificate-age 24h \\ # Alert 1 day before the certificate expires --provisioned # Alerts if the server is in provisioned modeAutonomous Agent Check A running instance can check itself using an Autonomous Agent, it will then public Cloud Events about it’s internal state and, optionally, expose it’s state to a local Prometheus Node Exporter via its text file directory.
watchers: - name: check_choria type: nagios interval: 5m # checks every 5 minutes, require the status file to be 15 minutes or newer properties: builtin: choria_status token_expire: 1d # alerts when the token expires soon pubcert_expire: 1d # alerts when the certificate expires soon last_message: 1h # alerts when no RPC message was received in 1 hourReview the Autonomous Agent section for full detail about these checks.
If you have Prometheus Node Exporter running locally with an argument --collector.textfile.directory=/var/lib/node_exporter/textfile set you can configure this path in Choria which would cause the above Autonomous Agent to write status to that directory:
plugin.choria.prometheus_textfile_directory = /var/lib/node_exporter/textfileLifecycle Events Choria will publish a number of events in Cloud Events format, these can be observed using choria tool event, this will include start, stop, provisioned etc events from every Choria Server instance.
Some details about these events are in these blog posts:
Choria Lifecycle Events Transitioning Events to Cloud Events `,description:"",tags:null,title:"Monitoring",uri:"/server/monitoring/index.html"},{breadcrumb:"Architecture",content:`Background Current State The Choria V1 protocol requires x509, there is no other option.
Experience with mcollective showed that companies had little appetite to understand or use esoteric security protocols, even those based on sound industry standard cryptographic methods. Further most companies already had mature x509 infrastructure either standalone or part of systems like Puppet which made for an easy adoption path.
Choria therefor is built on a protocol that requires x509 semantics and supports nothing else:
Every message is signed by a x509 key Every client-initiated message contains the x509 public key Servers listen on TLS using x509 public and private keys User identities are tied to the properties of the certificates User permissions and roles are tied to the identity of the certificate, very limited support for fine-grained roles All JWT files are signed by x509 keys Generally only RSA is supported mTLS is used to create a private network - requiring a purpose specific CA or intermediate CA in practice A local cache of certificates is used like a kind of safety check to catch credentials being re-issued Any NATS client connecting to Choria broker requires a cert/key/ca and do full mTLS Choria supports a mode combined with the AAA Server where a user does not need her own x509 certificate but holds a JWT instead obtained from an SSO service. In this scenario the AAA Server still holds a x509 cert (called a privileged certificate) and is allowed to sign and encode requests on behalf of others (holders of a JWT) by using its x509 key pair to sign on behalf of the user.
Problem Statement In practice this works well for most users, but those with very large or complex networks can run into problems either with corporate Certificate Authority policies or corporate CA configuration making it very hard to achieve a secure network with the facilities available. General CA infrastructure is also just getting a bit old and better alternatives exist. JWTs are now used pervasively in modern IT and the user based are more likely to accept their use for our needs.
We would like to explore, and enable, other use cases outside of server management such as IoT, purpose built backplanes, Kubernetes side cars and more, integration into Certificate Authorities in those cases is really problematic.
x509 signatures are big and slow x509 certificates are also huge and these go with every request x509 certificate management, especially across multiple client machines is very difficult Dealing with short-lived (minutes) x509 certificates can be really hard Not all CAs have sane enrollment, some requires private keys to be copied around making them useless Newer technologies like ed25519 is attractive as they use small keys and signatures and can also do things like DH Key exchange Using ed25519 opens the possibility of using ssh keys as signing keys, something many users have requested Obtaining private CAs or intermediate CAs is often impossible forcing CA reuse and nullifying the usefulness of the mTLS security Verification of certificates happen during caching rather than a separate check, more importantly the cache is used often as a means of retrieving privileged certs and more by id The local cert cache is deeply embedded in the v1 protocol, but it’s proven to be useless and most people disable its enforcing features - it cannot be disabled entirely As Choria have evolved we need a much more granular role based permissions on each connection - can they use streams, can they admin streams, can they make rpc requests etc More and more servers need to be able to make request either when publishing signed registration payloads or when interacting with Choria Services from within autonomous agents. With v1 protocol this was not possible. Solution Overview We will support an additional protocol, while maintaining v1 protocol, that will be based on JWTs signed using ed25519 that embed their public component in the signed JWT.
We have already done the work to design and incorporate the JWTs for clients and servers at the transport level but now need to move that work into the Choria protocol so clients can communicate with Choria without x509 certificates.
Transport Security Transport security is primarily about how the packets between Choria Broker and Choria Client/Server are secured but touches a bit on how users with access to the NATS Server are limited to just their traffic.
mTLS optional Chain of Trust for transport security In a mTLS secured network trust is established by way of the CA signing all certificates and all parties verifying this fact. Both sides of the TLS connection will verify the other side to ensure its certificate is signed by a cached local CA chain.
This way there can be no untrusted middlemen or session hijacking in the network path.
In practice, in enterprise networks, there are many challenges:
it’s often highly desirable to be able to hijack connections, for example to audit that PII doesn’t leave the legal jurisdiction it belongs in, many companies wish to disable the full mTLS while still maintaining strong identification of entities. it’s also desirable to deploy Choria Brokers using websocket protocol and offload the TLS work onto a load balancer - this would be quite complex with the current model. most enterprise have policies making CA rotation necessary and quite frequent, this makes mTLS completely unworkable at scale. dropping mTLS, or not being able to do mTLS, would impact the strength of identity since we combine the transport and identity in one cert certificate enrolment is done poorly, there are few protocols like ACME in use in Enterprises, often they would design their own enrollment, and mostly it involves moving keys between machines and are very slow So we will support verified or unverified TLS to the brokers, but clients and servers all must present a signed JWT when not in mTLS mode. This will split the identity from transport security and give people the choice to pick one without compromising the other.
Servers and clients will have:
An ed25519 seed file example server.seed kept private and never transmitted over the network A JWT file that holds: the public key of the ed25519 seed an identity a private network ID derived from the identity or seed Standard items like expiry times etc Additional permissions to control access to broker subjects The JWT will be signed by a trusted ed25519 key The broker will only allow connections that holds a valid, signed JWT where the signature is made using a trusted ed25519 key.
Organization and Chained Issuers Conceptually Choria Broker can separate connections into something called “accounts” in NATS terms, for Choria we call this an Organization. Today we support just one Organization - choria - but we will look to support more in future.
We will add a concept called an Organization Issuer that is a ed25519 key that must, on a basic level, sign all tokens. To facilitate separation of concerns in our centralized AAA mode the Issuer can delegate JWT issuing in a chain to downstream issuers. The tokens will validate as being signed by the issuer essentially.
We support storing the Organization Issuer offline in something like Vault and at the “AAA Login Server” level that issuing key can also be stored in a Vault like system.
Thus, we achieve the following chain of trust:
We know the JWT was issued by a trusted issuer We verify the connecting server or client has the ed25519 seed that match the JWT because the broker force a NONCE to be signed using the seed, the seed never traverse the network since the public part is embedded in the signed JWT The JWT tokens are therefor not bearer tokens and if they are stolen in-flight (remember no mTLS), one cannot connect with them or make any requests using them We have an identity that isn’t tied to the common name of a cert and so is more fluid and adaptable The broker should support denying all clients without JWTs In this way we can pick full mTLS when needed or JWT+ed25519 mode when needed and even mix and match the modes.
Reply Security Reply security is a quite difficult problem to solve since every reply would need to be individually encrypted and decrypted - unlike transport security - this is very CPU intensive, so we have never really done it at scale.
Still, its highly desirable to hide replies destined for a specific user from other users, even those with access to the broker using their own JWT tokens.
Using the callerID as key we calculate a private inbox using the hex encoded md5(callerID), we use this to construct reply subjects for all uses, even access to other subjects like the Streams API.
The broker will set up permissions ensuring that only the callerID can access replies. This way as long as there are unique callerIDs the replies from all systems are private.
We still do not encrypt the traffic in-transit (see point about PII and desired man-in-the-middle in Enterprises), but the replies are private to the user.
% sudo choria jwt client.jwt ... Private Network ID: 7419405695a186147a0de38f7e31a509... ... % choria req choria_util info --debug DEBU[0000] Publishing message with reply to choria.reply.7419405695a186147a0de38f7e31a509.4e27ca6493cb4576bb78e90ea35df38c component=clientHere we can see the reply is set to match <collective>.reply.<private network id>.<request id>, the broker ensures the holder of this JWT cannot subscribe to other users replies.
To facilitate debugging users with the OrgAdmin permission, default not granted, on their tokens can view all replies.
Submission and Registration Data Security As each server will have a ed25519 seed and a JWT embedding the public key we will support, optionally, signing Choria Submission and Registration messages. Signatures and Tokens will be included in headers.
This way should a system need to be created where the node will ask in an async manner for operations to be done against it, think host-detected issues triggering auto remediation, these messages originating from Submission will be signed.
Recipients of these messages can be certain that the message originated from a place that had access to the nodes private key.
See #1873
Identity Identity primarily concerns Choria Requests, this is who is the one making the request for the use by AAA.
Traditionally this is extracted from the x509 certificate common name and have some dumb rules like x.choria or x.privileged.choria since x509 certificates don’t really have a strong concept of boolean permissions.
This is awful and arbitrary, in the new model callers should be whatever they like and a flag on the JWT would identify it as privileged or not (#1836).
Caller Identity Identity would always be extracted from the JWT of the final client. In the case of the AAA Service we would need to have the ability to include the client JWT as well as the signer JWT and the signature:
When the signer JWT isn’t set we ensure the client signed it. When the signer JWT is set we ensure the JWT has the right permission to sign others requests (#1836) The identity of the client JWT is used for the request We should be able to issue JWTs that can only be used in conjunction with an AAA server who signs their requests (#1840) This would be the identity used in things like RBAC, Audit logs and more.
The broker might set the NATS user to the identity to assist with debugging.
Request Signatures Today requests are signed by the x509/RSA key, we’d just sign it with the ed25519 seed instead. We would not support any form of server side cache.
Client JWTs will gain permissions that state they have fleet management access and, optionally, that fleet management access requires signatures.
Issuing JWT tokens Traditionally you would use whatever your CA does for enrolling certificates and choria enroll might help you out if you’re lucky to have a system that supports that.
For others, it would be up to the user to deliver the key, cert and ca to the right locations.
Having Server enroll separate from Client enroll is good, since its conceivable that those will be done in very different places and with different auth mechanisms.
Servers Servers would get their JWT token from the Choria Provisioner, this is supported today and that supports setting permissions and more. The Provisioner would hold a JWT that is a Chain Issuer allowing it to sign JWTs for servers.
Clients The current AAA Server should be extended to allow client enrollment, essentially this is already supported but there is no allowance for the client seed and new behaviors. The signing request should be extended with a signature made using the seed and the service should verify it - essentially same as the NONCE in the broker.
The AAA Service would support marking a user as standalone - he can make his own requests without AAA and has his own seed - or as requiring AAA service (#1840). He might have his own seed for signing the broker NONCE but cannot make RPC requests that were not signed by AAA service.
The AAA Login handler would hold a JWT that is a Chain Issuer allow it to sign JWTs for the clients and set policies and permissions.
The choria jwt command must also be able to issue client credentials.
Non Choria clients - like lets say a random node nats client - would need to get their hands on a JWT and seed as well, and they will have to connect with that. So there will have to be a way to enroll them, probably choria jwt or choria login with their user marked as being long term valid.
A final class of client is one that needs a short-lived permission to make a very specific request. Imagine some external orchestrator wants to invoke choria req or choria kv for a particular use. Ideally this external Orchestrator would be able to issue a JWT that would allow this to happen on any unix user. In this scenario choria login should be able to take a bearer token and present that to AAA service during choria login. The bearer token would be signed by the orchestrator and trusted by the AAA, the bearer token would be very short-lived and essentially single use. It will be used to facilitate login, Choria JWT creation and more so that the unix user would still have an ed25519 seed, but the Choria Client JWT would be custom and short-lived and restricted to purpose.
Federation The federation system allows for moving requests and replies between uncoupled networks - essentially it’s a protocol converter and gateway.
We would not in the past create federation that would cross CA boundaries as resigning all the requests and replies was impossible. With the new system the Federation Broker should be able to have a token with Authentication Delegation set and just re-sign the request en-route. This will allow it to do translation between networks and ID schemes.
Implementation The protocol in Choria largely defines the bytes that traverse the network and couples quite tightly with the security providers for encoding, signing etc.
In the work to support v2 protocol we are also revisiting the design of the security plugins to be more generic and support non x509 key data.
Protocol Layered protocols are used widely and bring with them a lot of flexibility in replacing some layer with another, for example: Ethernet -> IP -> TCP -> HTTP -> REST.
Choria has a similar design:
( Transport ( Secure Request or Reply ( Request or Reply ( Any bytes, often: RPC Request or Reply ) ) ) )The efforts with v2 protocol is to replace Transport, Secure and Request/Reply with a new design, still based on JSON, but with better choices internally.
Request A request holds the actual bytes being moved around and various claims about who is making the request.
Field v1 Description protocol protocol The protocol version for this request io.choria.protocol.v2.request message payload The arbitrary data contained in the request - like a RPC request - as base64 encoded bytes id requestid The unique ID for the request, logged in AAA etc sender senderid Typically the host that the request was initiated from caller callerid Who made the request in the form of kind=name collective collective Collective this request is targeted at agent agent The agent this request is targeted at ttl ttl How long this request is valid for time time The unix nano time the request was created (unix time in v1) filter filter The request filter Secure Request A secure request wraps a Request, signs it and prevents any tampering with its content.
The signature - having been made with a private key - also conveys identity and confirms the claimed identity in the Request matches what cryptographic keys are held.
The main purpose of the Secure Request is to verify what can be verified about the Request and make immutable the rest. For example, we can’t exactly verify the request time and TTL, but we can prevent it from being changed by an attacker by signing it. The caller in the Request is not verified in the Request since it’s just an arbitrary string, however the Secure Request being signed using something unique to the caller, private key, confirms the information in the request.
So the end result is immutable, or at least tamper evident, metadata about a request and likewise the request payload or message.
Field v1 Description protocol protocol The protocol version for this secure request io.choria.protocol.v2.secure_request request message The request held in the Secure Request as base64 bytes signature signature A signature made of the request using the ed25519 seed of the caller caller pubcert The JWT of the caller signer n/a The JWT of the delegated signer, present when the AAA server is used Reply A reply is created in response from a request and holds the request id in its payload
Field v1 Description protocol protocol The protocol version for this reply io.choria.protocol.v2.reply message payload The arbitrary data contained in the reply - like a RPC reply request requestid The ID of the request this reply relates to sender senderid The host sending the reply agent agent The agent the reply originates from time time The unix nano time the request was created (unix time in v1) Secure Reply A secure reply wraps a Reply, signs it and prevents any tampering with its content. The hash is a fast way to test validity of the reply.
Like the Secure Request the Secure Reply wraps the Reply in a way that makes it tamper evident via signatures and hashes.
The v2 protocol includes a signature and sender JWT however in practice this is mostly not going to be used as too costly on the receiver, however might be used for registration payload verification.
Signatures add quite a bit to the payload here, as the JWT has to be sent with, so it can be disabled using plugin.security.choria.sign_replies in the new security provider.
Field v1 Description protocol protocol The protocol version for this secure reply io.choria.protocol.v2.secure_reply reply message The reply held in the Secure Request as base64 bytes hash hash A sha256 of the reply signature n/a A signature made using the ed25519 seed of the sender sender n/a The JWT of the sending host Transport The transport packet is the last layer that gets sent over NATS, it holds no message specific data.
Field v1 Description protocol protocol The protocol version for this transport io.choria.protocol.v2.transport data data The payload to be transport, a Secure Request or Secure Reply base64 encoded headers headers Optional headers Headers:
Field v1 Description reply reply-to A transport specific response channel for this message, used in requests sender mc_sender The host that sent this message trace seen-by A trace of host/broker pairs that the message traversed federation federation Headers to assist federation Federation:
Field v1 Description request req The request ID a federated message belongs to reply reply-to The original reply before federation targets targets The identities who the federated message is for Chained Tokens Verification We created a Chained Token system in #1900 that allows a Organization Issuer to delegate Client and Server creation to Chained Issuers.
From a usage perspective you can say tokens.ParseClientIDToken(t, pubk) where the public key is the public part of the Organization Issuer, even when the token t is signed by a Chain Issuer. The intention is to make the configuration of a chain much easier, you only have to configure the issuer for an Organization.
Additionally the expiry of the Chain Issuer is encoded in the token, if the issuer expires first the issued token is also considered expired.
The way this is achieved is with a series of claims and signatures as described here:
The Organization Issuer for an Organization is simply an ed25519 key for the moment. If that Org Issuer is just signing some client, server or provisioner nothing special is done, it’s just signing a JWT like normal.
However if the Org Issuer wants to create a token that can sign other tokens additional information is added a Clent token, it’s called the Chain Issuer:
{ "iss": "I-514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec", "jti": "0ujsswThIGTUYm2K8FjOOfXtY1K", "ou": "choria", "public_key": "bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687", "purpose": "choria_client_id", "tcs": "3f815723734c78ceaba5fb506347565f85fe2a0334c038ba2370c7f53f35e6c7c75ed3e95b531b6049426638201c39639dbf9b711fba5d866e7e3e30be02b401" } jti is a unique ID for this token. It’s a kskuid, the time component must match the issued at time iss field indicates it is signed by a Issuer with public key 514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec. public_key is the public part of the ed25519 seed for the Chain Issuer aaa_chain_delegator tcs is a signature made of [chain issuer id].[chain issuer public key] using the Org Issuer private key, in other words sig("0ujsswThIGTUYm2K8FjOOfXtY1K.bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687", orgIssuerPrik) The Chain Issuer JWT is signed by the Organization Issuer This way we can verify that the Chain Issuer comes from the Issuer both by verifying the signature but also we have a piece of information that cannot be changed down the line (the tcs, signed by the Org Issuer key) which we will see again later.
In code this information, signatures etc can all be added using chainIssuer.AddOrgIssuerData(issuerPrik), with this added the token chainIssuer can issue other tokens. For a possible future integration with systems like Vault we would call out to the Vault API to sign the tcs plain text and then sign the token, hence the Organization Issuer private key never needs to leave Vault.
Now when the Chain Issuer wants to issue a new Client or Server token additional information is again added:
{ "callerid": "up=rip", "iss": "C-0ujsswThIGTUYm2K8FjOOfXtY1K.bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687", "issexp": 1700153647, "jti": "b2375f965abe4bfbaf131b585cf5e1a1", "ou": "choria", "public_key": "676d07de6721ee396754d4e4d5fa4ee2b59a6f3b8208e760ca614bc66000e740", "purpose": "choria_client_id", "tcs": "3f815723734c78ceaba5fb506347565f85fe2a0334c038ba2370c7f53f35e6c7c75ed3e95b531b6049426638201c39639dbf9b711fba5d866e7e3e30be02b401.a9da5f3946c1b472f1c886912bfe5559f261e4663016846e231095bd2e16a8a253657196a5c17231fb095bc3a2d1e89e1edaddcec35dd050303e5d9cda968a04" } jti is a unique id for this token iss indicates a Chain Issuer with token ID (jti) 0ujsswThIGTUYm2K8FjOOfXtY1K issued this token and his public key is bd2588d3dc309d536461caa11c0d6f639e89d7a09dc43eae052f3fb32e2d8687 (the one from the previous example) issexp indicates when the Chain Issuer expires tcs is made up of first creating sigdata [client token jti].[chain issuer tcs] and then combining that [chain issuer tcs].[sig(sigdata, chainIssuerPrik)] This way we can, given the signed Client token and the Org Issuer Public key, validate by going backwards over these claims:
Extract the Chain Issuer tcs, public key and id from iss and tcs Verify the Organization Issuer signed the tcs of the Chain Issuer in this token, which also verifies the public key in the issuer Verify the tcs signature part of the Client using public key of the Chain Issuer Verify the expiry of the Chain Issuer General Improvements The security plugins handle signing, encoding, extracting of IDs and validating signatures. The current security plugins are all implemented around x509.
We will make some general improvements, rename some functions and add a few bits to the interface, detail to be discovered during implementation.
Move the API to []byte based API #1844 Remove some string orientated security apis Make the JWT authoritative for the secure channel name so we can stop using md5 Develop a tool that can decode and dump/view network packets #1484 The entire concept of the cache to be removed #1842 Default collective when v2 is used will be choria #1885 Submission can sign messages #1873 The protocol code should be instances not a singleton so each can have unique contexts and logging Stronger AAA interactions by signing NONCE like data in login and sign requests Potentially entirely remove the concept of Trusted Signers that was a mid term stop gap till this work is complete, only used by 1 users as far as we are aware `,description:"",tags:null,title:"V2 Network Protocol",uri:"/adr/001/index.html"},{breadcrumb:"Tech Previews",content:`This is a guide for early adopters who wish to test and study the Version 2 Protocol and Security project.
Warning This is a Hard Mode guide that does everything manually and with no Configuration Management.
Requirements Choria Nightly Choria AAA Service Nightly Choria Provisioner Nightly Docker on Intel CPU Security Credentials Security is by means of a ed25519 key that signs JWTs, some JWTs form a chain and can sign others. Regardless of the signer verification can be done using the public key associated with the Organization Issuer.
The Organization Issuer can be kept offline with Provisioning and AAA being delegated authorities capable of signing servers and clients but these are optional components - the Organization Issuer can directly sign Clients and Servers allowing them to operate without the other central components.
Deployment Methods We demonstrate two deployment methods:
Decentralized - like traditional Choria with only a broker as shared component Centralized AAA and Provisioning - uses Choria AAA Service and Choria Provisioner for low-touch auto enrolment of Clients and Servers Additionally, we show how Hashicorp Vault can be integrated to manage the Organization Issuer
Tip We recommend reviewers really dig into the details here, we do have a Docker Compose environment with this all setup.
Decentralized deployment In this model we will deploy a system that resembles the basic architecture diagram below
We have only the Brokers as central architecture with no Central AAA or Provisioning.
We will not use mTLS in this case. mTLS is supported but a major advantage of this mode is that it’s not required.
Docker We will need two Docker networks and 3 instances - broker, server, client and issuer.
$ docker network create choria_v2proto $ docker network create choria_issuer $ docker pull registry.choria.io/choria-nightly/choria:nightly $ docker run -ti --rm --entrypoint bash \\ --network choria_v2proto \\ --hostname broker.example.net \\ registry.choria.io/choria-nightly/choria:nightly -l $ docker run -ti --rm --entrypoint bash \\ --network choria_v2proto \\ --hostname server.example.net \\ registry.choria.io/choria-nightly/choria:nightly -l $ docker run -ti --rm --entrypoint bash \\ --network choria_v2proto \\ --hostname client.example.net \\ registry.choria.io/choria-nightly/choria:nightly -l $ docker run -ti --rm --entrypoint bash \\ --network choria_issuer \\ --hostname issuer.example.net registry.choria.io/choria-nightly/choria:nightly -lThe issuer is not needed per-se but will demonstrate that the Issuer credentials never need to near the managed network.
Keys and JWTs In this Scenario we need:
An Organization Issuer keypair A client JWT for each user A server JWT for each server x509 certificate for the broker TLS port In this scenario you are responsible for creating and distributing the keys and tokens.
Organization Issuer The Organization Issuer is the root of the Trust Chain and is a ed25519 key, let’s create the keypair on the issuer node:
[choria@issuer ~]$ mkdir -p development/issuer [choria@issuer ~]$ choria jwt keys development/issuer/private.key development/issuer/public.key Public Key: b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 Ed25519 seed saved in development/issuer/private.key Warning This key should be kept private and ideally in a Hashicorp Vault server. See a later section for guidance on Vault.
Broker JWT and Config Every broker needs a ed25519 Keypair and a signed JWT.
First we create a keypair on the broker, the private key never leaves the broker:
[choria@broker ~]$ choria jwt keys /etc/choria/private.key /etc/choria/public.key Public Key: 8918c1c7a4aeb4d4ad16729dc9b9c12df021d9296106eb5f072b224aa8f8eee9 Ed25519 seed saved in /etc/choria/private.keyPass the Public Key to the Organization Issuer who creates a JWT:
[choria@issuer ~]$ mkdir -p development/broker/broker.example.net [choria@issuer ~]$ choria jwt server development/broker/broker.example.net/token.jwt \\ broker.example.net \\ 8918c1c7a4aeb4d4ad16729dc9b9c12df021d9296106eb5f072b224aa8f8eee9 \\ development/issuer/private.key \\ --collectives=choriaWith access to just the Broker public key the Organization Issuer can create a server token, pass this back to the server who stores it in /etc/choria/broker.jwt.
Tip Note that for version 2 protocol the default collective is ["choria"].
[choria@issuer ~]$ choria jwt development/broker/broker.example.net/token.jwt development/issuer/public.key Validated Server Token development/server/server.example.net/token.jwt Identity: server.example.net Expires At: 2023-12-08 13:03:23 +0000 UTC (364d23h59m41s) Collectives: choria Public Key: 8918c1c7a4aeb4d4ad16729dc9b9c12df021d9296106eb5f072b224aa8f8eee9 Organization Unit: choria Private Network ID: 92328d88bef9d063480fd4b0ec5e4879 Broker Permissions: No server specific permissions grantedWe pass the JWT back to the broker and save in /etc/choria/broker.jwt.
The broker need x509 certificates to open the TLS network port, here we just self-sign one but you can get those from anywhere.
[choria@broker ~]$ openssl genrsa -out /etc/choria/broker-tls.key 2048 Generating RSA private key, 2048 bit long modulus (2 primes) ..+++++ ....................................................................................................+++++ e is 65537 (0x010001) [choria@broker ~]$ openssl req -new -x509 -sha256 -key /etc/choria/broker-tls.key \\ -out /etc/choria/broker-tls.cert -days 365 -subj "/O=Choria.io/CN=broker.example.net"With all in place it should look like this:
[choria@broker ~]$ find /etc/choria/ /etc/choria/ /etc/choria/broker.conf /etc/choria/broker-tls.key /etc/choria/broker-tls.cert /etc/choria/private.key /etc/choria/public.key /etc/choria/broker.jwtWe create the broker configuration in /etc/choria/broker.conf and start it, you need to change your issuer here:
# The name of the organization to configure, for now only supports choria plugin.security.issuer.names = choria # The public key from the issuer plugin.security.issuer.choria.public = b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 # Configures access to broker internal statistics and more plugin.choria.network.system.password = sYst3m # Used later in the Provisioner based setup plugin.choria.network.provisioning.client_password = s3cret plugin.choria.stats_port = 8222 plugin.choria.broker_network = true plugin.choria.network.client_port = 4222 plugin.choria.network.stream.store = /data plugin.choria.network.system.user = system loglevel = info plugin.choria.use_srv = false plugin.security.provider = choria plugin.security.choria.certificate = /etc/choria/broker-tls.cert plugin.security.choria.key = /etc/choria/broker-tls.key plugin.security.choria.token_file = /etc/choria/broker.jwt plugin.security.choria.seed_file = /etc/choria/private.keyLet’s start the broker, showing the key lines from the output here:
$ choria broker run --config /etc/choria/broker.conf INFO[0000] Choria Broker version 0.99.0.20221201 starting with config /etc/choria/broker.conf INFO[0000] Starting Network Broker WARN[0000] Allowing unverified TLS connections for Organization Issuer issued connections component=network WARN[0000] Loaded Organization Issuer choria with public key b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 component=network INFO[0000] Listening for client connections on [::]:4222 component=network_broker ...Server JWT Every server needs a ed25519 Keypair and a signed JWT.
The server process is identical to the broker process except change broker.example.net to server.example.net in identities and make obvious file name changes. Servers do not need any x509 certificates like brokers.
Now we can configure and start the server, place this in /etc/choria/server.conf:
# The name of the organization to configure, for now only supports choria plugin.security.issuer.names = choria # The public key from the issuer plugin.security.issuer.choria.public = b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 # We enable authorization and set it to trust the JWT tokens policy rpcauthorization = 1 rpcauthprovider = aaasvc plugin.security.provider = choria plugin.security.choria.token_file = /etc/choria/server.jwt plugin.security.choria.seed_file = /etc/choria/private.key plugin.choria.middleware_hosts = nats://broker.example.net:4222And finally let’s run the server, showing key log lines only:
Tip Servers usually run as root, here as the choria user as it’s in the container
[choria@server ~]$ choria server run --config /etc/choria/server.conf INFO[0000] Choria Server version 0.99.0.20221201 starting with config /etc/choria/server.conf using protocol version 2 INFO[0000] Setting JWT token and unique reply queues based on JWT for "server.example.net" component=server connection=server.example.net identity=server.example.net INFO[0000] Setting custom inbox prefix based on unique ID to choria.reply.77e64440ac709c0836487e5b77334e5b component=server connection=server.example.net identity=server.example.netClient JWT Every client needs a ed25519 keypair and a signed JWT.
We will create a client that has access to Choria Streams and the ability to manage the fleet without any AAA Server.
The client will create their own keypair, so we run that in the client node:
[choria@client ~]$ mkdir -p ~/.config/choria/ [choria@client ~]$ choria jwt keys ~/.config/choria/private.key ~/.config/choria/public.key Public Key: 4bbfddb9f70f4b39f5b13bac8e83a9a31c3af49e388da86a666f8615101bc818 Ed25519 seed saved in /home/choria/.config/choria/private.keyThis client private.key should be kept private and not shared, the JWT can be created with knowledge of the public key only.
The client pass their Public Key to the Organization Issuer who creates a JWT on the Issuer node:
Tip Here we use choria as the identity, this would match the unix user name.
If a user is on many machines, create a JWT per machine.
[choria@issuer ~]$ mkdir -p development/client/choria [choria@issuer ~]$ choria jwt client development/client/choria/token.jwt choria development/issuer/private.key \\ --public-key 4bbfddb9f70f4b39f5b13bac8e83a9a31c3af49e388da86a666f8615101bc818 \\ --stream-admin \\ --event-viewer \\ --elections-user \\ --service \\ --fleet-management \\ --agents '*' \\ --validity 1y Saved token to development/client/choria/token.jwt, use 'choria jwt view development/client/choria/token.jwt' to view itWith access to the Issuer private key, but not the user private key, we can create a JWT for the user. Since we have no AAA Service we mark this user as a service which allows them to have a long token validity. We set a policy allowing all agent access, in real life this would be an Open Policy Agent policy.
[choria@issuer ~]$ choria jwt development/client/choria/token.jwt development/issuer/public.key Validated Client Identification Token development/client/choria/token.jwt Caller ID: choria Organization Unit: choria Allowed Agents: * Public Key: 4bbfddb9f70f4b39f5b13bac8e83a9a31c3af49e388da86a666f8615101bc818 Private Network ID: 0a63c70a8817f5ef4d19d055ce6513f1 Expires At: 2023-12-08 12:54:07 +0000 UTC (364d23h59m19s) Client Permissions: Can manage Choria fleet nodes Can use Leader Elections Can view Lifecycle and Autonomous Agent events Can administer Choria Streams Can access the Broker system account Can have an extended token lifetimePass the JWT back to the client who saves it in ~/.config/choria/token.jwt.
[choria@client ~]$ find ~/.config /home/choria/.config /home/choria/.config/choria /home/choria/.config/choria/private.key /home/choria/.config/choria/public.key /home/choria/.config/choria/token.jwtWe create a system-wide client configuration in /etc/choria/client.conf:
loglevel = warn plugin.choria.middleware_hosts = broker.example.net:4222 plugin.choria.network.system.user = system plugin.choria.network.system.password = sYst3m plugin.security.provider = choria plugin.security.choria.token_file = ~/.config/choria/token.jwt plugin.security.choria.seed_file = ~/.config/choria/private.keyWe can now test the client:
[choria@client ~]$ choria ping server.example.net time=3 ms ---- ping statistics ---- 1 replies max: 4ms min: 4ms avg: 4ms overhead: 12msOther commands like choria req choria_util info should work demonstrating authorization works and choria broker server list should list the broker indicating Broker System Account access works. After a minute or so choria broker stream ls will show a list of Streams demonstrating Choria Streams authority worked.
Self Provisioned and AAA Integrated Deployment Thus far we had to manually sign and configure every single server and client, we had to copy files around and more, it’s all a bit tedious.
Lets see how Choria can configure itself and how user management can be centralized for self-service user enrollment.
Instead of signing Server JWTs servers will go to Choria Provisioner to obtain credentials and configuration Instead of issuing Client JWTs for every user that are long-lasting we will use a central authorization flow to issue short-lived JWTs and distribute them Docker We will create re-use the networks we made before, and we can keep the same issuer.example.net and broker.example.net.
So stop and recreate your server and client containers, we’ll 2 more container during the guide.
Issuer The issuer is unchanged from before, so just follow the same steps as before or keep the one you have if you followed the Decentralized section.
Broker The broker is unchanged from before, so just follow the same steps as before or keep the one you have if you followed the earlier Decentralized section.
You will note we have a setting in the broker.conf:
plugin.choria.network.provisioning.client_password = s3cretThis instructs the broker that we will be connecting servers needing provisioning to it. You should see a log line like:
WARN[0000] Allowing Provisioner connections subject to JWT claims component=networkProvisioner The Choria Provisioner is a service that configures new Choria Servers:
Enrolls servers into the Issuer Create a per-node configuration Deploys Open Policy Agent policies Configures the server Optionally perform version upgrades We have CLI tooling allowing you to re-provision servers on demand and more. Review its documentation for full detail.
It needs to connect to the broker, so it needs JWT token, let’s create the container and create the private key:
Since the container does not have the choria command we have to jump some hoops, we’ll make a local storage directory for its configuration and keys and then mount that in.
host$ mkdir provisioner host$ docker run -v \`pwd\`/provisioner:/etc/choria-provisioner --user root --entrypoint bash --rm -ti registry.choria.io/choria-nightly/choria:nightly -l [root@5d96691fa69f /]# choria jwt keys /etc/choria-provisioner/private.key /etc/choria-provisioner/public.key Public Key: a8c15c0a4bbae0646d0c5aa92513f4d58c2c0e51464b4b267bb3a42dbebd1c8a [root@5d96691fa69f /]# chown -R choria:choria /etc/choria-provisioner/ [root@5d96691fa69f /]# exitNext we create a provisioner JWT and save it in provisioner/token.jwt
[choria@issuer ~]$ mkdir -p development/provisioner [choria@issuer ~]$ choria jwt client development/provisioner/token.jwt provisioner_signer development/issuer/private.key \\ --public-key a8c15c0a4bbae0646d0c5aa92513f4d58c2c0e51464b4b267bb3a42dbebd1c8a \\ --server-provisioner \\ --validity 365d \\ --issuerHere we create a token that has access to the NATS Account new machines will join, it’s a year valid and it can issue new credentials.
Place the development/provisioner/token.jwt on your host in provisioner/token.jwt, next to private.key and public.key we made above.
Tip We will not delve much into the Provisioner configuration details, visit its documentation site for details.
We need to configure how the Provisioner use these files, create provisioner/client.cfg on your host:
plugin.security.provider = choria plugin.security.choria.token_file = /etc/choria-provisioner/token.jwt plugin.security.choria.seed_file = /etc/choria-provisioner/private.key identity = provisioner_signer plugin.choria.middleware_hosts = nats://broker.example.net:4222Next we create the Provisioner configuration file in provisioner/choria-provisioner.yaml:
# The issuer public key jwt_verify_cert: b3989a299278750427b00213693c2ca02146476a361667682446230842836da8 interval: 1m logfile: /dev/stdout loglevel: info helper: /etc/choria-provisioner/helper.rb token: s3cret choria_insecure: false site: PREVIEW broker_provisioning_password: s3cret jwt_signing_key: private.key jwt_signing_token: token.jwt features: jwt: true ed25519: trueNext we need the script that generates per-node configuration, store the helper.rb in provisioner/helper.rb and change the ISSUER constant near the top.
host$ vi provisioner/helper.rb host$ chmod a+x provisioner/helper.rb host$ sudo chown -R 2048:2048 provisionerWe can now run our Provisioner:
host$ docker run -ti --rm -v \`pwd\`/provisioner:/etc/choria-provisioner \\ --network choria_v2proto \\ --hostname provisioner.example.net \\ choria/provisioner:nightlyServers For servers, we are going to need the RPM (already in the container) and a new file /etc/choria/provisioning.jwt. This is read by the server process and tells it to enter provisioning mode.
The JWT file is basically just a configuration file signed by our Issuer. The server reads it unvalidated but the Provisioner will ensure the incoming server holds the token signed by our Issuer.
[choria@issuer ~]$ choria jwt prov development/server/provisioning.jwt \\ development/issuer/private.key \\ --token s3cret \\ --urls nats://broker.example.net:4222 \\ --protocol-v2 \\ --default Saved token to development/server/provisioning.jwt, use 'choria jwt view development/server/provisioning.jwt' to view it [choria@issuer ~]$ choria jwt development/server/provisioning.jwt Unvalidated Provisioning Token development/server/provisioning.jwt Token: ***** Secure: false URLS: nats://broker.example.net:4222 Provisioning by default: true Using version 2 Protocol: true Server Version Upgrades: false Standard Claims: { "purpose": "choria_provisioning", "iss": "Choria Tokens Package v0.99.0.20221210", "sub": "choria_provisioning", "nbf": 1670850426, "iat": 1670850426, "jti": "60a2973b10304184b997f9ea50eeb7a4" }Copy this to your host before running the server. We need to mount this token into the server containers, no other configuration is needed:
host$ docker run -ti --rm \\ --network choria_v2proto \\ --hostname server.example.net \\ -v \`pwd\`/provisioning.jwt:/etc/choria/provisioning.jwt \\ registry.choria.io/choria-nightly/choria:nightly server run --config /etc/choria/server.confThe server will now start and connect to the Broker, communicate with the Provisioner and restart itself. After restart the client (configured next) will be able to communicate with it.
Previously we had to use choria jwt keys and choria jwt server to create Private keys and to issue a signed JWT and then manually transfer that to the Server and configure the Server. This all happens under Choria Provisioner control and takes just a few milliseconds. The only site-unique part about a machine is now the provisioner.jwt that is shared by your fleet, so it’s easily placed there during base image build or configuration management. You could issue node-unique provisioning.jwt files with extended information in them and in your helper.rb perform additional validation if you needed that much control.
AAA Service To provide a self-service system for Clients configure the Choria AAA Service. Here we will configure it to both issue JWTs and Sign individual requests - meaning it’s required to be available for every RPC request. The signing part is optional though, and we could skip that, using it only to obtain JWT tokens.
Tip We will not delve much into the AAA Service configuration details, visit its documentation site for details.
We need to issue 3 sets of credentials here:
One to sign users who request their JWT using choria login called the Chain Signer, since this is HTTP it also needs a x509 certificate One to sign RPC requests on behalf of users after evaluating policies and auditing requests called the Request Signer One to connect to Choria Broker with and run a Choria RPC Service that will receive requests from users to sign their requests called a Signer Service. Like the Provisioner the AAA Service container does not have the choria binary, so we need to jump some hoops to make the keys and configuration:
host$ docker run -ti --rm -v \`pwd\`/aaasvc:/etc/aaasvc --user root --entrypoint bash registry.choria.io/choria-nightly/choria:nightly -l [root@38f75c90e475 /]# openssl genrsa -out /etc/aaasvc/https-private.key 2048 Generating RSA private key, 2048 bit long modulus (2 primes) ........................................................................................+++++ ...................................+++++ [root@38f75c90e475 /]# openssl req -new -x509 -sha256 -key /etc/aaasvc/https-private.key -out /etc/aaasvc/https-public.crt -days 365 -subj "/O=Choria.io/CN=aaa.choria.local" [root@38f75c90e475 /]# choria jwt keys /etc/aaasvc/chain-signer-private.key /etc/aaasvc/chain-signer-public.key Public Key: 17807f2c5fa959383ee5851813863426525c081f6464556e5dec482e815caded Ed25519 seed saved in /etc/aaasvc/chain-signer-private.keyWe create a self-signed x509 certificate since the Authentication service runs over HTTPS, you can use any certificate for this.
Further we create a key used to sign JWTs for users running choria login, it needs a special JWT:
[choria@issuer ~]$ mkdir -p development/aaasvc [choria@issuer ~]$ choria jwt client development/aaasvc/chain-signer.jwt aaa_chain_signer \\ development/issuer/private.key \\ --public-key 17807f2c5fa959383ee5851813863426525c081f6464556e5dec482e815caded \\ --no-fleet-management \\ --issuer \\ --validity 365d Saved token to client development/aaasvc/chain-signer.jwt, use 'choria jwt view client development/aaasvc/chain-signer.jwt' to view itCopy this file to the temporary AAA container above as /etc/aaasvc/chain-signer.jwt.
Next we create the credentials that will sign every RPC request:
host$ docker run -ti --rm -v \`pwd\`/aaasvc:/etc/aaasvc --user root --entrypoint bash registry.choria.io/choria-nightly/choria:nightly -l [root@38f75c90e475 /]# choria jwt keys /etc/aaasvc/request-signer-private.key /etc/aaasvc/reqeuest-signer-public.key Public Key: 535e9d337e555b9bf9079269567b8d9cb812fdf54797e5d5441ed778f1db68d8 Ed25519 seed saved in /etc/aaasvc/request-signer-private.keyThis is the key used to sign individual user RPC requests on their behalf, it needs a special JWT:
[choria@issuer ~]$ mkdir -p development/aaasvc [choria@issuer ~]$ choria jwt client development/aaasvc/request-signer.jwt aaa_request_signer \\ development/issuer/private.key \\ --public-key 535e9d337e555b9bf9079269567b8d9cb812fdf54797e5d5441ed778f1db68d8 \\ --no-fleet-management \\ --auth-delegation \\ --validity 365d Saved token to development/aaasvc/request-signer.jwt, use 'choria jwt view development/aaasvc/request-signer.jwt' to view itPlace it in /etc/aaasvc/request-signer.jwt on the AAA Service container above.
Finally, we need to create the credentials that allow the request signer to run as a Choria Service.
host$ docker run -ti --rm -v \`pwd\`/aaasvc:/etc/aaasvc --user root --entrypoint bash registry.choria.io/choria-nightly/choria:nightly -l [root@38f75c90e475 /]# choria jwt keys /etc/aaasvc/signer-service-private.key /etc/aaasvc/signer-service-public.key Public Key: c5c1323f66bb8324d019249e3476d9f11f9deb70efa60255593dde30ef3b8a01 Ed25519 seed saved in /etc/aaasvc/signer-service-private.keyLet’s create the server JWT that will host the RPC Service for signing requests
[choria@issuer ~]$ choria jwt server development/aaasvc/signer-service.jwt \\ aaa.example.net \\ c5c1323f66bb8324d019249e3476d9f11f9deb70efa60255593dde30ef3b8a01 \\ development/issuer/private.key \\ --org choria \\ --collectives choria \\ --service \\ --validity 365dPlace it in /etc/aaasvc/signer-service.jwt on the AAA Service container above.
We can now configure the various parts of the AAA Service, it needs a /etc/aaasvc/choria.conf to connect to the network with:
identity = aaa.example.net plugin.security.provider = choria plugin.security.choria.seed_file = /etc/aaasvc/signer-service-private.key plugin.security.choria.token_file = /etc/aaasvc/signer-service.jwt plugin.choria.middleware_hosts = broker.example.net:4222We need an /etc/aaasvc/aaasvc.conf:
Tip See the User List Authenticator docs about user, passwords and more. The passwords below are all secret.
{ "choria_config": "/etc/aaasvc/choria.conf", "logfile": "/dev/stdout", "loglevel": "info", "authenticator": "userlist", "authorizer": "opa", "signer": "basicjwt", "monitor_port": 8081, "site": "PREVIEW", "tls_certificate": "/etc/aaasvc/https-public.crt", "tls_key":"/etc/aaasvc/https-private.key", "port":8080, "basicjwt_signer": { "signing_certificate": "/etc/aaasvc/chain-signer-public.key", "signing_token": "/etc/aaasvc/request-signer.jwt", "signing_seed": "/etc/aaasvc/request-signer-private.key", "max_validity":"2h", "choria_service": true }, "userlist_authenticator": { "signing_key": "/etc/aaasvc/chain-signer-private.key", "signing_token": "/etc/aaasvc/chain-signer.jwt", "validity": "1h", "users": [ { "username": "admin", "password": "$2a$05$zQIl4gUZbqmKhpQhIeWx3uDWhAZaHoG34zW1ZsxXQt5xpL5f4uyny", "opa_policy_file": "/etc/aaasvc/admin.rego", "broker_permissions": { "org_admin": true, "system_user": true, "signed_fleet_management": true } }, { "username": "streams", "password": "$2a$05$zQIl4gUZbqmKhpQhIeWx3uDWhAZaHoG34zW1ZsxXQt5xpL5f4uyny", "broker_permissions": { "streams_admin": true } }, { "username": "choria", "password": "$2a$05$zQIl4gUZbqmKhpQhIeWx3uDWhAZaHoG34zW1ZsxXQt5xpL5f4uyny", "opa_policy_file": "/etc/aaasvc/admin.rego", "broker_permissions": { "signed_fleet_management": true } } ] } } Warning See the AAA Service Docs for writing real policies.
Finally, we create an Open Policy Agent policy for the Choria Users, this one just allows everything. Place it in /etc/aaasvc/admin.rego
package io.choria.aaasvc default allow = trueWe can now start the AAA Service:
host$ sudo chown -R 2048:2048 aaasvc host$ docker run -ti --rm \\ -v \`pwd\`/aaasvc:/etc/aaasvc \\ --network choria_v2proto \\ --hostname aaa.example.net \\ choria/aaasvc:nightly run --config /etc/aaasvc/aaasvc.conf Client Choria Clients will now enroll using choria login which will issue them a 1-hour valid JWT with their policies and more embedded.
Lets create a new client container:
$ docker run -ti --rm --entrypoint bash \\ --network choria_v2proto \\ --hostname client.example.net \\ registry.choria.io/choria-nightly/choria:nightly -lWe create a system-wide client configuration in /etc/choria/client.conf:
loglevel = warn plugin.choria.middleware_hosts = broker.example.net:4222 plugin.choria.network.system.user = system plugin.choria.network.system.password = sYst3m plugin.security.provider = choria plugin.security.choria.token_file = ~/.config/choria/client.jwt plugin.security.choria.seed_file = ~/.config/choria/client.key plugin.choria.security.request_signer.service = true plugin.login.aaasvc.login.url = https://aaa.example.net:8080/choria/v1/loginUsers can now run choria login and authenticate using on of the usernames and the password secret.
The client is now entirely self-service, the token expires every hour, and they just run choria login again. They can do this on as many machines as they have and admins do not get involved.
Every RPC request the client makes will be signed by the AAA Service after Authorization against the OPA Policy and auditing the outcome. Servers will also validate the OPA policy before executing anything.
Vault as Organization Issuer We support using Hashicorp Vault as the Organization Issuer. In that mode the Private Key is created inside Vault and never has to leave Vault at all.
Warning Here we’ll show the developer mode Vault you should use a Production deployment of Vault and not a simple developer local build.
Starting Vault We start Vault in dev mode with a static secret defined:
$ vault server -dev -dev-root-token-id root ==> Vault server configuration: Api Address: http://127.0.0.1:8200 Cgo: disabled Cluster Address: https://127.0.0.1:8201 .... WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory and starts unsealed with a single unseal key. The root token is already authenticated to the CLI, so you can immediately begin using Vault. You may need to set the following environment variables: $ export VAULT_ADDR='http://127.0.0.1:8200' The unseal key and root token are displayed below in case you want to seal/unseal the Vault or re-authenticate. Unseal Key: JKyF70iBqv3d9rreY9rhY0/EQ9ornriTZHV+kVWpJ+w= Root Token: root Development mode should NOT be used in production installations!Configuring the Transit Secrets Engine Choria relies on the Transit Secrets Engine to offload signing of keys.
Let’s enable that:
$ export VAULT_ADDR='http://127.0.0.1:8200 $ export VAULT_TOKEN='root' $ vault secrets enable transit Success! Enabled the transit secrets engine at: transit/Create the Issuer We use the Vault API to create an ed25519 key stored in Vault storage:
$ export VAULT_ADDR='http://127.0.0.1:8200 $ export VAULT_TOKEN='root' $ vault write transit/keys/choria_issuer type=ed25519 Success! Data written to: transit/keys/choria_issuer $ vault read transit/keys/choria_issuer Key Value --- ----- allow_plaintext_backup false auto_rotate_period 0s deletion_allowed false derived false exportable false imported_key false keys map[1:map[creation_time:2022-12-12T11:21:23.248802439+01:00 name:ed25519 public_key:IZu6TyYAwWeuyD3Q0tEiCGbYBjkRjoOcWO/OI9PDmOE=]] latest_version 1 min_available_version 0 min_decryption_version 1 min_encryption_version 0 name choria_issuer supports_decryption false supports_derivation true supports_encryption false supports_signing true type ed25519Here we see that the public key is shown as public_key:IZu6TyYAwWeuyD3Q0tEiCGbYBjkRjoOcWO/OI9PDmOE=, lets turn that into a hex encoded string:
Tip If saving the public key to a file ensure there is no trailing new line
$ echo IZu6TyYAwWeuyD3Q0tEiCGbYBjkRjoOcWO/OI9PDmOE=|base64 -d|xxd -p -c 64 219bba4f2600c167aec83dd0d2d1220866d80639118e839c58efce23d3c398e1This is the Organization Issuer you configure in your broker and elsewhere.
Signing JWTs using Vault The choria jwt commands support the --vault flag that requires VAULT_ADDR and VAULT_TOKEN to be set in environment.
$ choria jwt server \\ token.jwt \\ server.example.net \\ 3f2d5d01f3c5caa0cd7359512c7e2d9a727fa0392f47f50adee1866bf02cbe12 \\ choria_issuer \\ --collectives=choria \\ --vaultHere we pass --vault and instead of a path to the Issuer Private Key we give the name choria_issuer that we created in Vault.
`,description:"",tags:null,title:"V2 Protocol & Security",uri:"/previews/protov2/index.html"},{breadcrumb:"",content:`Choria Server is the component that runs on every managed device. It hosts various plugins that can be accessed remotely via a RPC layer.
It’s a stable and robust agent designed to run forever with minimal resource overheads on managed devices.
Features Hosts Choria RPC Agents Hosts Choria Autonomous Agents Hosts foundational technology for Choria Scout Supports optional self-provisioning and enrollment into a Choria network in a IoT device like manner Communicates using a JSON based network protocol with extensive JSON Schemas Deep RBAC integration for Authentication, Authorization and Auditing Supports mTLS or JWT token based security layers with, optional, integration into Enterprise SSO, IAM and systems like Hashicorp Vault Supports Open Policy Agent for Authorization Emits Cloud Events for network management and observability Embeddable in Go applications to provide in-process management for automation backplanes Extensive features related to gathering and streaming of Node Metadata Distributed as RPM, Deb, DMG, MSI across many architectures `,description:"",tags:null,title:"Choria Server",uri:"/server/index.html"},{breadcrumb:"",content:`We distribute an RPM, Debs, MSIs, Exes and Docker containers for the Choria Server and Broker.
Enterprise Linux We publish RPM releases but also nightly builds to our repositories.
Users of our Puppet modules will already have these repositories available.
Release [choria_release] name=Choria Orchestrator Releases mirrorlist=http://mirrorlists.choria.io/yum/release/el/$releasever/$basearch.txt enabled=True gpgcheck=True repo_gpgcheck=True gpgkey=https://choria.io/RELEASE-GPG-KEY metadata_expire=300 sslcacert=/etc/pki/tls/certs/ca-bundle.crt sslverify=TrueNightly Nightly releases are named and versioned choria-0.99.0.20221109-1.el7.x86_64.rpm where the last part of the version is the date.
[choria_nightly] name=Choria Orchestrator Nightly mirrorlist=http://mirrorlists.choria.io//yum/nightly/el/$releasever/$basearch.txt enabled=True gpgcheck=True repo_gpgcheck=True gpgkey=https://choria.io/NIGHTLY-GPG-KEY metadata_expire=300 sslcacert=/etc/pki/tls/certs/ca-bundle.crt sslverify=TrueDebian We publish release packages for Debian systems on our APT repositories:
deb mirror://mirrorlists.choria.io/apt/release/debian/bullseye/mirrors.txt debian bullseyeDocker There is a docker container for releases registry.choria.io/choria/choria:latest with nightly builds at registry.choria.io/choria-nightly/choria with tags nightly and nightly-YYYYMMDD.
`,description:"",tags:null,title:"Installation",uri:"/installation/index.html"},{breadcrumb:"",content:`This is a list of all known Configuration settings. This list is based on declared settings within the Choria Go code base and so will not cover 100% of settings - plugins can contribute their own settings which are note known at compile time.
Version Hint Built on 16 Mar 25 13:40 UTC using version 0.29.4
Run-time configuration The run-time configuration can be inspected using choria tool config --config /etc/choria/server.cfg, this will show the active configuration.
Search and list directives In addition to the full list below you can get configuration information for your version using the CLI:
% choria tool config security.provider .... Configuration item: plugin.security.provider ║ Value: puppet ║ Data Type: string ║ Validation: enum=puppet,file,pkcs11,certmanager,choria ║ Default: puppet ║ ║ The Security Provider to use ╙─Data Types A few special types are defined, the rest map to standard Go types
Type Description comma_split A comma separated list of strings, possibly with spaces between duration A duration such as 1h, 300ms, -1.5h or 2h45m. Valid time units are ns, ms, s, m, h path_split A list of paths split by a OS specific PATH separator path_string A path that can include ~ for the users home directory strings A space separated list of strings title_string A string that will be stored as a Title String Index classesfile collectives color default_discovery_method default_discovery_options discovery_timeout identity libdir logfile loglevel main_collective plugin.choria.adapters plugin.choria.agent_provider.mcorpc.agent_shim plugin.choria.agent_provider.mcorpc.config plugin.choria.agent_provider.mcorpc.libdir plugin.choria.broker_federation plugin.choria.broker_network plugin.choria.discovery.broadcast.windowed_timeout plugin.choria.discovery.external.command plugin.choria.discovery.inventory.source plugin.choria.executor.enabled plugin.choria.executor.spool plugin.choria.federation.cluster plugin.choria.federation.collectives plugin.choria.federation_middleware_hosts plugin.choria.legacy_lifecycle_format plugin.choria.machine.signing_key plugin.choria.machine.store plugin.choria.middleware_hosts plugin.choria.network.client_hosts plugin.choria.network.client_port plugin.choria.network.client_signer_cert plugin.choria.network.client_tls_force_required plugin.choria.network.deny_server_connections plugin.choria.network.gateway_name plugin.choria.network.gateway_port plugin.choria.network.gateway_remotes plugin.choria.network.leafnode_port plugin.choria.network.leafnode_remotes plugin.choria.network.listen_address plugin.choria.network.mapping.names plugin.choria.network.peer_password plugin.choria.network.peer_port plugin.choria.network.peer_user plugin.choria.network.peers plugin.choria.network.pprof_port plugin.choria.network.provisioning.client_password plugin.choria.network.provisioning.provisioner_without_token plugin.choria.network.provisioning.signer_cert plugin.choria.network.public_url plugin.choria.network.server_signer_cert plugin.choria.network.soft_shutdown_timeout plugin.choria.network.stream.advisory_replicas plugin.choria.network.stream.advisory_retention plugin.choria.network.stream.event_replicas plugin.choria.network.stream.event_retention plugin.choria.network.stream.executor_replicas plugin.choria.network.stream.executor_retention plugin.choria.network.stream.leader_election_replicas plugin.choria.network.stream.leader_election_ttl plugin.choria.network.stream.machine_replicas plugin.choria.network.stream.machine_retention plugin.choria.network.stream.manage_streams plugin.choria.network.stream.store plugin.choria.network.system.password plugin.choria.network.system.user plugin.choria.network.tls_timeout plugin.choria.network.websocket_advertise plugin.choria.network.websocket_port plugin.choria.network.write_deadline plugin.choria.prometheus_textfile_directory plugin.choria.puppetca_host plugin.choria.puppetca_port plugin.choria.puppetdb_host plugin.choria.puppetdb_port plugin.choria.puppetserver_host plugin.choria.puppetserver_port plugin.choria.registration.file_content.compression plugin.choria.registration.file_content.data plugin.choria.registration.file_content.target plugin.choria.registration.inventory_content.compression plugin.choria.registration.inventory_content.target plugin.choria.require_client_filter plugin.choria.security.certname_whitelist plugin.choria.security.privileged_users plugin.choria.security.request_signer.seed_file plugin.choria.security.request_signer.service plugin.choria.security.request_signer.token_file plugin.choria.security.request_signer.url plugin.choria.security.server.seed_file plugin.choria.security.server.token_file plugin.choria.server.provision plugin.choria.server.provision.allow_update plugin.choria.services.registry.cache plugin.choria.services.registry.store plugin.choria.srv_domain plugin.choria.ssldir plugin.choria.stats_address plugin.choria.stats_port plugin.choria.status_file_path plugin.choria.status_update_interval plugin.choria.submission.max_spool_size plugin.choria.submission.spool plugin.choria.use_srv plugin.login.aaasvc.login.url plugin.machines.bucket plugin.machines.check_interval plugin.machines.download plugin.machines.key plugin.machines.poll_interval plugin.machines.purge plugin.machines.signing_key plugin.nats.credentials plugin.nats.pass plugin.nats.user plugin.rpcaudit.logfile plugin.rpcaudit.logfile.group plugin.rpcaudit.logfile.mode plugin.scout.agent_disabled plugin.scout.goss.denied_local_resources plugin.scout.goss.denied_remote_resources plugin.scout.overrides plugin.scout.tags plugin.security.certmanager.alt_names plugin.security.certmanager.api_version plugin.security.certmanager.issuer plugin.security.certmanager.namespace plugin.security.certmanager.replace plugin.security.choria.ca plugin.security.choria.certificate plugin.security.choria.key plugin.security.choria.seed_file plugin.security.choria.sign_replies plugin.security.choria.token_file plugin.security.choria.trusted_signers plugin.security.cipher_suites plugin.security.client_anon_tls plugin.security.ecc_curves plugin.security.file.ca plugin.security.file.certificate plugin.security.file.key plugin.security.issuer.names plugin.security.pkcs11.driver_file plugin.security.pkcs11.slot plugin.security.provider plugin.security.server_anon_tls plugin.security.support_legacy_certificates plugin.yaml registerinterval registration registration_collective registration_splay rpcaudit rpcauthorization rpcauthprovider rpclimitmethod soft_shutdown_timeout ttl classesfile Type: path_string Default Value: /opt/puppetlabs/puppet/cache/state/classes.txt Path to a file listing configuration classes applied to a node, used in matches using Class filters
collectives Type: comma_split The list of known Sub Collectives this node will join or communicate with, Servers will subscribe the node and each agent to each sub collective and Clients will publish to a chosen sub collective. Defaults to the build settin build.DefaultCollectives
color Type: boolean Default Value: true Disables or enable CLI color
default_discovery_method Type: string Validation: enum=mc,broadcast,puppetdb,choria,external,inventory Default Value: mc The default discovery plugin to use. The default “mc” uses a network broadcast, “choria” uses PuppetDB, external calls external commands
default_discovery_options Type: strings Default options to pass to the discovery plugin
discovery_timeout Type: integer Default Value: 2 How long to wait for responses while doing broadcast discovery
identity Type: string The identity this machine is known as, when empty it’s derived based on the operating system hostname or by calling facter fqdn
libdir Type: path_split The directory where Agents, DDLs and other plugins are found
logfile Type: path_string Default Value: stdout The file to write logs to, when set to ‘discard’ logging will be disabled. Also supports ‘stdout’ and ‘stderr’ as special log destinations.
loglevel Type: string Validation: enum=debug,info,warn,error,fatal Default Value: info The lowest level log to add to the logfile
main_collective Type: string The Sub Collective where a Client will publish to when no specific Sub Collective is configured
plugin.choria.adapters Type: comma_split Additional Information: https://choria.io/docs/adapters/ The list of Data Adapters to activate
plugin.choria.agent_provider.mcorpc.agent_shim Type: string Path to the helper used to call MCollective Ruby agents
plugin.choria.agent_provider.mcorpc.config Type: string Path to the MCollective configuration file used when running MCollective Ruby agents
plugin.choria.agent_provider.mcorpc.libdir Type: path_split Path to the libdir MCollective Ruby agents should have
plugin.choria.broker_federation Type: boolean Additional Information: https://choria.io/docs/federation/ Default Value: false Enables the Federation Broker
plugin.choria.broker_network Type: boolean Additional Information: https://choria.io/docs/deployment/broker/ Default Value: false Enables the Network Broker
plugin.choria.discovery.broadcast.windowed_timeout Type: boolean Enables the experimental dynamic timeout for choria/mc discovery
plugin.choria.discovery.external.command Type: path_string The command to use for external discovery
plugin.choria.discovery.inventory.source Type: path_string The file to read for inventory discovery
plugin.choria.executor.enabled Type: boolean Default Value: false Enables the long running command executor
plugin.choria.executor.spool Type: path_string Path where the command executor writes state
plugin.choria.federation.cluster Type: string Additional Information: https://choria.io/docs/federation/ Default Value: mcollective The cluster name a Federation Broker serves
plugin.choria.federation.collectives Type: comma_split Additional Information: https://choria.io/docs/federation/ Environment Variable: CHORIA_FED_COLLECTIVE List of known remote collectives accessible via Federation Brokers
plugin.choria.federation_middleware_hosts Type: comma_split Additional Information: https://choria.io/docs/federation/ Middleware brokers used by the Federation Broker, if unset uses SRV
plugin.choria.legacy_lifecycle_format Type: boolean Default Value: 0 When enabled will publish lifecycle events in the legacy format, else Cloud Events format is used
plugin.choria.machine.signing_key Type: string Public key used to sign data for watchers like machines watcher. Will override the value compiled in or in the watcher definitions if set here. This is primarily to allow development environments to use different private keys.
plugin.choria.machine.store Type: string Additional Information: https://choria.io/docs/autoagents/ Directory where Autonomous Agents are stored
plugin.choria.middleware_hosts Type: comma_split Set specific middleware hosts in the format host:port, if unset uses SRV
plugin.choria.network.client_hosts Type: comma_split CIDRs to limit client connections from, appropriate ACLs are added based on this
plugin.choria.network.client_port Type: integer Additional Information: https://choria.io/docs/deployment/broker/ Default Value: 4222 Port the Network Broker will accept client connections on
plugin.choria.network.client_signer_cert Type: comma_split Fully qualified paths to the public certificates used by the AAA Service to sign client JWT tokens. This enables users with signed JWTs to use unverified TLS to connect. Can also be a list of ed25519 public keys.
plugin.choria.network.client_tls_force_required Type: boolean Force requiring/not requiring TLS for all clients
plugin.choria.network.deny_server_connections Type: boolean Set ACLs denying server connections to this broker
plugin.choria.network.gateway_name Type: string Default Value: CHORIA Name for the Super Cluster
plugin.choria.network.gateway_port Type: integer Default Value: 0 Port to listen on for Super Cluster connections
plugin.choria.network.gateway_remotes Type: comma_split List of remote Super Clusters to connect to
plugin.choria.network.leafnode_port Type: integer Default Value: 0 Port to listen on for Leafnode connections, disabled with 0
plugin.choria.network.leafnode_remotes Type: comma_split Remote networks to connect to as a Leafnode
plugin.choria.network.listen_address Type: string Additional Information: https://choria.io/docs/deployment/broker/ Default Value: :: Address the Network Broker will listen on
plugin.choria.network.mapping.names Type: comma_split List of subject remappings to apply
plugin.choria.network.peer_password Type: string Password to use when connecting to cluster peers
plugin.choria.network.peer_port Type: integer Additional Information: https://choria.io/docs/deployment/broker/ Port used to communicate with other local cluster peers
plugin.choria.network.peer_user Type: string Username to use when connecting to cluster peers
plugin.choria.network.peers Type: comma_split Additional Information: https://choria.io/docs/deployment/broker/ List of cluster peers in host:port format
plugin.choria.network.pprof_port Type: integer Default Value: 0 The port the network broker will listen on for pprof requests
plugin.choria.network.provisioning.client_password Type: string Password the provisioned clients should use to connect
plugin.choria.network.provisioning.provisioner_without_token Type: boolean Allows a provisioner without a token to connect over TLS using username and password. This facilitates v1 provisioning on an Issuer based network
plugin.choria.network.provisioning.signer_cert Type: path_string Path to the public cert that signs provisioning tokens, enables accepting provisioning connections into the provisioning account
plugin.choria.network.public_url Type: string Name:Port to advertise to clients, useful when fronted by a proxy
plugin.choria.network.server_signer_cert Type: comma_split Fully qualified Paths to the public certificates used by the Provisioner Service to sign server JWT tokens. This enables servers with signed JWTs to use unverified TLS to connect. Can also be a list of ed25519 public keys.
plugin.choria.network.soft_shutdown_timeout Type: integer Default Value: 60 The amount of time to allow the broker to exit, after this memory and thread dumps will be performed and a force exit will be done
plugin.choria.network.stream.advisory_replicas Type: integer Default Value: -1 When configuring Stream advisories storage ensure data is replicated in the cluster over this many servers, -1 means count of peers
plugin.choria.network.stream.advisory_retention Type: duration Default Value: 168h When not zero enables retaining Stream advisories in the Stream Store
plugin.choria.network.stream.event_replicas Type: integer Default Value: -1 When configuring LifeCycle events ensure data is replicated in the cluster over this many servers, -1 means count of peers
plugin.choria.network.stream.event_retention Type: duration Default Value: 24h When not zero enables retaining Lifecycle events in the Stream Store
plugin.choria.network.stream.executor_replicas Type: integer Default Value: -1 When configuring Executor events ensure data is replicated in the cluster over this many servers, -1 means count of peers
plugin.choria.network.stream.executor_retention Type: duration Default Value: 24h When not zero enables retaining Executor events in the Stream Store
plugin.choria.network.stream.leader_election_replicas Type: integer Default Value: -1 When configuring Stream based Leader Election storage ensure data is replicated in the cluster over this many servers, -1 means count of peers
plugin.choria.network.stream.leader_election_ttl Type: duration Default Value: 1m The TTL for leader election, leaders must vote at least this frequently to remain leader
plugin.choria.network.stream.machine_replicas Type: integer Default Value: -1 When configuring Autonomous Agent event storage ensure data is replicated in the cluster over this many servers, -1 means count of peers
plugin.choria.network.stream.machine_retention Type: duration Default Value: 24h When not zero enables retaining Autonomous Agent events in the Stream Store
plugin.choria.network.stream.manage_streams Type: boolean Default Value: 1 When set to zero will disable managing the standard streams on this node
plugin.choria.network.stream.store Type: path_string Enables Streaming data persistence stored in this path
plugin.choria.network.system.password Type: string Password used to access the Choria system account
plugin.choria.network.system.user Type: string Username used to access the Choria system account
plugin.choria.network.tls_timeout Type: integer Default Value: 2 Time to allow for TLS connections to establish, increase on slow or very large networks
plugin.choria.network.websocket_advertise Type: string Additional Information: https://choria.io/docs/deployment/broker/ The URL to advertise for websocket connections
plugin.choria.network.websocket_port Type: integer Additional Information: https://choria.io/docs/deployment/broker/ Port to listen on for websocket connections
plugin.choria.network.write_deadline Type: duration Default Value: 10s How long to allow clients to process traffic before treating them as slow, increase this on large networks or slow networks
plugin.choria.prometheus_textfile_directory Type: path_string Directory where Prometheus Node Exporter textfile collector reads data
plugin.choria.puppetca_host Type: string Default Value: puppet The hostname where your Puppet Certificate Authority can be found
plugin.choria.puppetca_port Type: integer Default Value: 8140 The port your Puppet Certificate Authority listens on
plugin.choria.puppetdb_host Type: string The host hosting your PuppetDB, used by the “choria” discovery plugin
plugin.choria.puppetdb_port Type: integer Default Value: 8081 The port your PuppetDB listens on
plugin.choria.puppetserver_host Type: string Default Value: puppet The hostname where your Puppet Server can be found
plugin.choria.puppetserver_port Type: integer Default Value: 8140 The port your Puppet Server listens on
plugin.choria.registration.file_content.compression Type: boolean Default Value: true Enables gzip compression of registration data
plugin.choria.registration.file_content.data Type: string YAML or JSON file to use as data source for registration
plugin.choria.registration.file_content.target Type: string NATS Subject to publish registration data to
plugin.choria.registration.inventory_content.compression Type: boolean Default Value: true Enables gzip compression of registration data
plugin.choria.registration.inventory_content.target Type: string NATS Subject to publish registration data to
plugin.choria.require_client_filter Type: boolean Default Value: false If a client filter should always be required, only used in Go clients
plugin.choria.security.certname_whitelist Type: comma_split Default Value: .mcollective$,.choria$ Patterns of certificate names that are allowed to be clients
plugin.choria.security.privileged_users Type: comma_split Additional Information: https://choria.io/docs/configuration/aaa/ Default Value: .privileged.mcollective$,.privileged.choria$ Patterns of certificate names that would be considered privileged and able to set custom callers
plugin.choria.security.request_signer.seed_file Type: path_string Additional Information: https://github.com/choria-io/aaasvc Path to the seed file used to access a Central Authenticator
plugin.choria.security.request_signer.service Type: boolean Additional Information: https://choria-io.github.io/aaasvc/ Enables signing requests via Choria RPC requests
plugin.choria.security.request_signer.token_file Type: path_string Additional Information: https://github.com/choria-io/aaasvc Path to the token used to access a Central Authenticator
plugin.choria.security.request_signer.url Type: string Additional Information: https://choria-io.github.io/aaasvc/ URL to the Signing Service
plugin.choria.security.server.seed_file Type: path_string The server token seed to use for authentication, defaults to server.seed in the same location as server.conf
plugin.choria.security.server.token_file Type: path_string The server token file to use for authentication, defaults to serer.jwt in the same location as server.conf
plugin.choria.server.provision Type: boolean Additional Information: https://choria-io.github.io/provisioner/ Default Value: false Specifically enable or disable provisioning
plugin.choria.server.provision.allow_update Type: boolean Additional Information: https://choria-io.github.io/provisioner/ Default Value: false Allows the provisioner to perform in-place version updates
plugin.choria.services.registry.cache Type: path_string Environment Variable: CHORIA_REGISTRY Directory where the Registry client stores DDLs found in the registry
plugin.choria.services.registry.store Type: path_string Directory where the Registry service finds DDLs to read
plugin.choria.srv_domain Type: string Additional Information: https://choria.io/docs/deployment/dns/ Environment Variable: CHORIA_SRV_DOMAIN The domain to use for SRV records, defaults to the domain the server FQDN is in
plugin.choria.ssldir Type: path_string The SSL directory, auto detected via Puppet, when specifically set Puppet will not be consulted
plugin.choria.stats_address Type: string Default Value: 127.0.0.1 The address to listen on for statistics
plugin.choria.stats_port Type: integer Default Value: 0 The port to listen on for HTTP requests for statistics, setting to 0 disables it
plugin.choria.status_file_path Type: path_string Path to a JSON file to write server health information to regularly
plugin.choria.status_update_interval Type: integer Default Value: 30 How frequently to write to the status_file_path
plugin.choria.submission.max_spool_size Type: integer Default Value: 500 Maximum amount of messages allowed into each priority
plugin.choria.submission.spool Type: path_string Path to a directory holding messages to submit to the middleware
plugin.choria.use_srv Type: boolean Additional Information: https://choria.io/docs/deployment/dns/ Default Value: true If SRV record lookups should be attempted to find Puppet, PuppetDB, Brokers etc
plugin.login.aaasvc.login.url Type: comma_split Additional Information: https://choria-io.github.io/aaasvc/ List of URLs to attempt to login against when the remote signer is enabled
plugin.machines.bucket Type: string Default Value: CHORIA_PLUGINS The KV bucket to query for plugins to install
plugin.machines.check_interval Type: string Default Value: 30s How frequently to integrity check deployed autonomous agents
plugin.machines.download Type: boolean Activate run-time installation of Autonomous Agents
plugin.machines.key Type: string Default Value: machines The Key to query in KV bucket for plugins to install
plugin.machines.poll_interval Type: string Default Value: 1m How frequently to poll the KV bucket for updates
plugin.machines.purge Type: boolean Default Value: true Purge autonomous agents installed using other methods
plugin.machines.signing_key Type: string The public key to validate the plugins manifest with
plugin.nats.credentials Type: string Environment Variable: MCOLLECTIVE_NATS_CREDENTIALS The NATS 2.0 credentials to use, required for accessing NGS
plugin.nats.pass Type: string Environment Variable: MCOLLECTIVE_NATS_PASSWORD The password to use when connecting to the NATS server
plugin.nats.user Type: string Environment Variable: MCOLLECTIVE_NATS_USERNAME The user to connect to the NATS server as. When unset no username is used.
plugin.rpcaudit.logfile Type: path_string Path to the RPC audit log
plugin.rpcaudit.logfile.group Type: string User group to set file ownership to
plugin.rpcaudit.logfile.mode Type: string Default Value: 0600 File mode to apply to the file
plugin.scout.agent_disabled Type: boolean Disables the scout agent
plugin.scout.goss.denied_local_resources Type: comma_split List of resource types to deny for Goss manifests loaded from local disk
plugin.scout.goss.denied_remote_resources Type: comma_split Default Value: command List of resource types to deny when Goss manifests or variables were received over rpc
plugin.scout.overrides Type: path_string Path to a file holding overrides for Scout checks
plugin.scout.tags Type: path_string Path to a file holding tags for a Scout entity
plugin.security.certmanager.alt_names Type: comma_split when using Cert Manager security provider, add these additional names to the CSR
plugin.security.certmanager.api_version Type: string Default Value: v1 the API version to call in cert manager
plugin.security.certmanager.issuer Type: string When using Cert Manager security provider, the name of the issuer
plugin.security.certmanager.namespace Type: string Default Value: choria When using Cert Manager security provider, the namespace the issuer is in
plugin.security.certmanager.replace Type: boolean Default Value: true when using Cert Manager security provider, replace existing CSRs with new ones
plugin.security.choria.ca Type: path_string When using choria security provider, the path to the optional Certificate Authority public certificate
plugin.security.choria.certificate Type: path_string When using choria security provider, the path to the optional public certificate
plugin.security.choria.key Type: path_string When using choria security provider, the path to the optional private key
plugin.security.choria.seed_file Type: path_string The path to the seed file
plugin.security.choria.sign_replies Type: boolean Default Value: true Disables signing replies which would significantly trim down the size of replies but would remove the ability to verify signatures or verify message origin
plugin.security.choria.token_file Type: path_string The path to the JWT token file
plugin.security.choria.trusted_signers Type: comma_split Ed25119 public keys of entities allowed to sign client and server JWT tokens in hex encoded format
plugin.security.cipher_suites Type: comma_split List of allowed cipher suites
plugin.security.client_anon_tls Type: boolean Default Value: false Use anonymous TLS to the Choria brokers from a client, also disables security provider verification - only when a remote signer is set
plugin.security.ecc_curves Type: comma_split List of allowed ECC curves
plugin.security.file.ca Type: path_string When using file security provider, the path to the Certificate Authority public certificate
plugin.security.file.certificate Type: path_string When using file security provider, the path to the public certificate
plugin.security.file.key Type: path_string When using file security provider, the path to the private key
plugin.security.issuer.names Type: comma_split List of names of valid issuers this server will accept, set indvidiaul issuer data using plugin.security.issuer..public
plugin.security.pkcs11.driver_file Type: path_string Additional Information: https://choria.io/blog/post/2019/09/09/pkcs11/ When using the pkcs11 security provider, the path to the PCS11 driver file
plugin.security.pkcs11.slot Type: integer Additional Information: https://choria.io/blog/post/2019/09/09/pkcs11/ When using the pkcs11 security provider, the slot to use in the device
plugin.security.provider Type: string Validation: enum=puppet,file,pkcs11,certmanager,choria Default Value: puppet The Security Provider to use
plugin.security.server_anon_tls Type: boolean Default Value: false Use anonymous TLS to the Choria brokers from a server
plugin.security.support_legacy_certificates Type: boolean Default Value: false Allow certificates without SANs to be used
plugin.yaml Type: path_string Where to look for YAML or JSON based facts
registerinterval Type: integer Default Value: 300 How often to publish registration data
registration Type: comma_split The plugins used when publishing Registration data, when this is unset or empty sending registration data is disabled
registration_collective Type: string The Sub Collective to publish registration data to
registration_splay Type: boolean Default Value: true When true delays initial registration publish by a random period up to registerinterval following registration publishes will be at registerinterval without further splay
rpcaudit Type: boolean Additional Information: https://choria.io/docs/configuration/aaa/ Default Value: false When enabled uses rpcauditprovider to audit RPC requests processed by the server
rpcauthorization Type: boolean Additional Information: https://choria.io/docs/configuration/aaa/ Default Value: true When enables authorization is performed on every RPC request based on rpcauthprovider
rpcauthprovider Type: title_string Additional Information: https://choria.io/docs/configuration/aaa/ Default Value: action_policy The Authorization system to use
rpclimitmethod Type: string Validation: enum=first,random Default Value: first When limiting nodes to a subset of discovered nodes this is the method to use, random is influenced by
soft_shutdown_timeout Type: integer Default Value: 2 The amount of time to allow the server to exit, after this memory and thread dumps will be performed and a force exit will be done
ttl Type: integer Default Value: 60 How long published messages are allowed to linger on the network, lower numbers have a higher reliance on clocks being in sync
`,description:"",tags:null,title:"Config Reference",uri:"/configuration/index.html"},{breadcrumb:"",content:`These are documents describing some Architectural Designs
Document Description ADR-001 Background and design of Protocol version 2 and the Choria Issuer based security layer `,description:"",tags:null,title:"Architecture",uri:"/adr/index.html"},{breadcrumb:"",content:`Choria binary, being a compiled binary with no external dependencies, needs to be recompiled when adding certain kinds of plugin, changing some default locations or adding your own plugins.
The project provides the tooling to perform these builds and has a compile-time configuration that can be adjusted to local needs.
Requirements The host used to perform the compile need to have Docker on it and be able to fetch the registry.choria.io/choria/packager container. You can build a local version of the Packager using https://github.com/choria-io/packager.
In general you should only do this if you know what you are doing, have special needs, want custom agents etc.
Plugins A number of plugins types are supported and we build many in at compile time ourselves.
The general process is that all the plugins in packager/plugins.yaml will be included in the build, if you want to add additional plugins you list them in packager/user_plugins.yaml.
If you wish to remove some default plugins you need to remove them from the packager/plugin.yaml.
In order to add your own RPC Agent you would list it in packager/user_plugins.yaml:
--- acme: ghe.example.net/backplane/acme_agentDuring your CI run go get ghe.example.net/backplane/acme_agent then go generate and start the build:
BUILD=foss VERSION=0.26.0acme rake buildYour plugin will now be included in the final build, see choria buildinfo -D for al ist of all dependencies, which should include your plugin.
Custom builds, paths and packages The choria-io/go-choria repository has packager/buildspec.yaml in it, this defines the binaries and packages to build, there are also some supporting files to call RPM, Deb etc.
Lets look at building a custom 64bit Linux binary with different paths and creating an Enterprise Linux 8 RPM.
flags_map: Version: github.com/choria-io/go-choria/build.Version SHA: github.com/choria-io/go-choria/build.SHA BuildTime: github.com/choria-io/go-choria/build.BuildDate ProvisionJWTFile: github.com/choria-io/go-choria/build.ProvisionJWTFile acme: compile_targets: defaults: output: backplane-{{version}}-{{os}}-{{arch}} flags: ProvisionJWTFile: /etc/acme/backplane/provisioning.jwt pre: - rm additional_agent_*.go || true - rm plugin_*.go || true - go generate --run plugin 64bit_linux: os: linux arch: amd64 packages: defaults: name: backplane display_name: Backplane bindir: /opt/acme/bin etcdir: /etc/acme/backplane release: 1 manage_conf: 1 manage_server_preset: 0 contact: Backplane Engineering <backplane@eng.example.com> rpm_group: System Environment/Base server_start_runlevels: "-" server_start_order: 50 broker_start_runlevels: "-" broker_start_order: 50 el8_64: template: el/el8 dist: el8 target_arch: x86_64 binary: 64bit_linuxWe can now run:
BUILD=acme VERSION=0.26.0acme rake buildWhen you are done you will have:
an rpm called backplane-0.26.0acme.el8.x86_64.rpm the binary will be /opt/acme/bin/backplane config files, log files, services all will be personalized around backplane it will have a custom path to the provisioning.jwt A number of things are customizable see the section at the top of the buildspec.yaml and comments in the build file.
`,description:"",tags:null,title:"Custom Packaging",uri:"/packaging/index.html"},{breadcrumb:"",content:`This section will from time-to-time contain guides on testing upcoming features and architectural changes.
`,description:"",tags:null,title:"Tech Previews",uri:"/previews/index.html"},{breadcrumb:"",content:"",description:"",tags:null,title:"Categories",uri:"/categories/index.html"},{breadcrumb:"",content:"",description:"",tags:null,title:"Tags",uri:"/tags/index.html"}]